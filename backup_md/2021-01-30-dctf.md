---
layout: post
date: 2021-01-30 00:00:03
title: "Dreamhack CTF Season 1 Round #4 Write Up"
categories: CTF
tags: [REDIS]
author:
  - Jeongwon Jo

---
![](https://github.com/wjddnjs33/image2/blob/main/dctf10th.png?raw=true)

2021년 1월 30일 오전 9시부터 오후 6시까지 Theory에서 CTF를 주최하였습니다. 이번 대회는 전체적으로 난이도가 낮아 운이 좋게 10등을 할 수 있었고, 풀면서 그나마 공을 들였던 `WEB_2021A_Medium`라는 문제의 Write Up을 작성해보겠습니다.<br>

## (Web) WEB_2021A_Medium [936 pts]

> WEB_2021A_Medium 문제는 관리자 계정으로 로그인하고, 관리자 계정을 활성화 한 후에 FLAG를 읽는 문제입니다.

```python
@app.route("/flag")
def flag():
    if not is_login():
        return alert("No Signin!")
    myusr = User.query.filter_by(userid=get_userid()).first()
    if myusr.userid == "admin" and myusr.auth:
        return render_template("flag.html", flag=FLAG)
    return alert("No Flag")
```
`/flag`를 보면 현재 로그인된 사용자가 `admin`이고, 계정이 활성화가 되어 있으면 `FLAG`를 보여주는 것을 볼 수 있습니다. 그럼 관리자 계정을 획득하고, 계정을 활성화 시켜보겠습니다.<br>

```python
(생략)
class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    userid = db.Column(db.String(80), unique=True)
    password = db.Column(db.String(80))
    email = db.Column(db.String(80))
    auth = db.Column(db.Boolean())

    def __init__(self, userid, password, email):
        self.userid = userid
        self.password = password
        self.email = email
        self.auth = False

    def to_json(self):
        return {
            "userid": self.userid.lower(),
            "password": self.password.lower(),
            "email": self.email.lower(),
            "auth": self.auth,
        }

(생략)

@app.route("/signin", methods=["GET", "POST"])
def signin():
    if is_login():
        return alert("Already Signin!", "/")
    if request.method == "GET":
        return render_template("signin.html")
    elif request.method == "POST":
        userid = request.form.get("userid", "")
        userpw = request.form.get("userpw", "")
        usr = User.query.filter_by(
            userid=userid, password=hashlib.md5(userpw.encode()).hexdigest()
        ).first()
        if not hasattr(usr, "userid"):
            return alert("Check userid or userpw")
        session["info"] = usr.to_json()
        return alert("Signin!", "/")
(생략)
```
로그인 로직을 보면 userid, userpw 값을 받아와서 로그인하는 것을 볼 수 있습니다. 여기서 session을 관리 할 때 to_json 함수를 이용해서 사용자 정보를 넣어주는 것을 볼 수 있습니다. to_json 함수를 보면 userid의 값을 lower 함수를 이용해 소문자로 만들어 세션으로 사용하는 것을 볼 수 있습니다. 즉, `ADMIN`이라는 사용자를 가입해서 로그인을 해주면 to_json 함수에 의해서 `admin`으로 로그인이 됩니다. 이를 통해 관리자 아이디는 쉽게 획득했습니다.<br>

```python
(생략)

class Auth:
    def __init__(self, email):
        self.email = email
        self.emailauth_key = f"auth:{self.email}"
        self.getcount_key = f"auth_count:{self.email}"

    def set(self):
        setcount = conn.get(self.email)
        if setcount:
            setcount = int(setcount) + 1
        else:
            setcount = 1
        if setcount < 5:
            self.random_key = f"{random.randint(111111, 999999):04d}"
            conn.set(self.emailauth_key, self.random_key)
            conn.set(self.getcount_key, "0")
            conn.set(self.email, setcount)
            return True
        else:
            return False

    def get(self):
        getcount = conn.get(self.getcount_key)
        if getcount:
            getcount = int(getcount) + 1
        else:
            getcount = 1
        if getcount < 5:
            conn.set(self.getcount_key, getcount)
            return conn.get(self.emailauth_key)
        else:
            return None

(생략)

@app.route("/email_verify", methods=["GET", "POST"])
def email_verify():
    if not is_login():
        return alert("No Signin!", "/")
    email = get_useremail()
    if request.method == "GET":
        return render_template("email_verify.html", email=email)
    elif request.method == "POST":
        auth = Auth(email)
        if not auth.set():
            return alert("Too many Auth")
        if send_mail(email, auth.random_key):
            return alert(f"Send Email To {email}", "/email_verify_chk")
        else:
            return alert("Send Email Err")


@app.route("/email_verify_chk", methods=["GET", "POST"])
def email_verify_chk():
    if not is_login():
        return alert("No Signin!", "/")
    email = get_useremail()
    if request.method == "GET":
        return render_template("email_verify_chk.html", email=email)
    elif request.method == "POST":
        auth = Auth(email)
        authcode = auth.get()
        if not authcode:
            return alert("Too many Auth or No Code Generated")
        else:
            code = request.form.get("code", "")
            if code == authcode:
                usr = User.query.filter_by(userid=get_userid()).first()
                usr.auth = True
                db.session.commit()
                session["info"] = usr.to_json()
                return alert("AUTH!")
            else:
                return alert("Check Code")
```
`/email_verify`는 보면 현재 사용자의 이메일로 인증 번호를 생성하는 로직입니다. 코드를 보면 현재 사용자의 이메일을 Auth 클래스의 인자로 넘겨주며 클래스를 생성하고, set 함수를 이용해서 인증 코드를 생성해서 디비에 저장하고 있는 것을 볼 수 있습니다.<br>

`/email_verify_chk`는 인증 번호를 입력 받고, 디비에 저장되어 있는 값과 비교해서 참이면 활성화를 해주고, 거짓이면 그대로 비활성화로 있습니다.<br>

```python
self.email = email
self.emailauth_key = f"auth:{self.email}"
self.getcount_key = f"auth_count:{self.email}"

conn.set(self.emailauth_key, self.random_key)
conn.set(self.getcount_key, "0")
conn.set(self.email, setcount)
```
위 코드를 보면 email 값을 이용해서 email, emailauth_key, getcount_key 값을 만들고, 이를 redis의 키로 사용하는 것을 볼 수 있습니다. 그리고 emailauth_key가 실제로 입력 받은 인증 번호와 비교를 하는 값 입니다. 하지만 우리는 이 값을 알아낼 수는 없지만 로직을 이해하고 있다면 쉽게 우회할 수 있습니다. 해당 로직에 대한 내용은 [드림핵 강의](https://dreamhack.io/learn/29#t209)에서 자세하게 다루고 있습니다. 이번 로직은 설명하기 귀찮고, 그냥 글을 보는 게 좋을 거 같습니다.<br>

- 시나리오<br>

1. `ADMIN`으로 회원 가입을 하고, `ADMIN`으로 로그인을 해서 관리자로 로그인을 한다.
2. `auth:admin`인 사용자를 하나 더 만들어서 로그인을 한 후에, 인증 코드를 받는다.
3. (2)번 시나리오에서의 로직 때문에 관리자가 `/email_verify_chk`에서 `입력 받은` 인증 코드와 비교되는 인증 코드가 1로 바뀐다.
4. 관리자에서 인증 코드를 1을 보내주면 관리자 게정이 활성화된다. 
5. 이제 FLAG를 읽으면 된다.<br>

위 내용은 그냥 링크 달아준 드림핵 강의를 한 번 보면 이해가 가실 겁니다.<br>

> FLAG : DH{3cd6941075580d889519fcf1bd422bd1}

---
